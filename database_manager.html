<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tangent SFF RPG Database Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <main id="main-content" class="w-full">
        <!-- Main content will be rendered here by JavaScript -->
    </main>


    <div id="entry-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-3/4 max-w-6xl max-h-[90vh] overflow-y-auto flex flex-col">
            <div class="p-8">
                <div class="flex justify-between items-center mb-6">
                    <h2 id="modal-title" class="text-2xl font-bold">Manage Entry</h2>
                    <div class="file-menu">
                        <button id="modal-data-btn" class="file-menu-button">DATA</button>
                        <div id="modal-data-dropdown" class="file-menu-dropdown">
                            </div>
                    </div>
                </div>
                <form id="entry-form" onsubmit="handleFormSubmit(event)">
                    <div id="form-fields" class="space-y-6">
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    <div id="summary-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-full max-w-4xl p-8 max-h-[90vh] overflow-y-auto">
            <h2 id="summary-title" class="text-2xl font-bold mb-6">Summary</h2>
            <div id="summary-content" class="space-y-4 text-gray-300 normal-case"></div>
            <div class="flex justify-end mt-8">
                <button id="summary-close-btn" class="btn btn-primary">Close</button>
            </div>
        </div>
    </div>


    <div id="confirm-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-full max-w-md p-8">
            <h2 id="confirm-title" class="text-xl font-bold mb-4">Are you sure?</h2>
            <p id="confirm-message" class="text-gray-400 mb-6">This action cannot be undone.</p>
            <div class="flex justify-end gap-2">
                <button id="confirm-cancel-btn" class="btn btn-secondary">CANCEL</button>
                <button id="confirm-ok-btn" class="btn btn-danger">CONFIRM</button>
            </div>
        </div>
    </div>

    <div id="unsaved-changes-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-full max-w-lg p-8">
            <h2 class="text-xl font-bold mb-4">Unsaved Changes</h2>
            <p class="text-gray-400 mb-6">You have unsaved changes. Do you want to save them before continuing?</p>
            <div class="flex justify-end gap-3">
                <button id="unsaved-cancel-btn" class="btn btn-secondary">CANCEL</button>
                <button id="unsaved-dismiss-btn" class="btn btn-danger">DISMISS CHANGES</button>
                <button id="unsaved-save-btn" class="btn btn-primary">SAVE & CONTINUE</button>
            </div>
        </div>
    </div>
    
    <div id="error-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-full max-w-md p-8">
            <h2 class="text-xl font-bold mb-4 text-red-500">Error</h2>
            <p id="error-message" class="text-gray-400 mb-6">Something went wrong.</p>
            <div class="flex justify-end">
                <button id="error-ok-btn" class="btn btn-primary">OK</button>
            </div>
        </div>
    </div>

    <div id="help-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-3/4 max-w-4xl max-h-[90vh] overflow-y-auto p-8">
            <h2 class="text-3xl font-bold mb-6 text-center">User Guide</h2>
            <div id="help-content" class="prose prose-invert max-w-none text-gray-300 normal-case space-y-4">
            </div>
            <div class="text-center font-bold text-sm pt-8 mt-6 border-t border-gray-600 normal-case" style="color: var(--text-subtle)">
                Wolfe.BT@TangentLLC
            </div>
            <div class="flex justify-end mt-8">
                <button id="help-close-btn" class="btn btn-primary">Close</button>
            </div>
        </div>
    </div>

    <div id="custom-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-[60] p-4 hidden modal-backdrop">
        <div class="modal-content w-full max-w-lg p-8">
            <h2 id="custom-modal-title" class="text-2xl font-bold mb-4 text-center"></h2>
            <div id="modal-choices" class="flex flex-col gap-2 max-h-96 overflow-y-auto mt-4"></div>
            <div class="flex justify-center gap-4 flex-wrap mt-4">
                <button id="modal-ok-btn" class="btn btn-primary" style="display: none;">OK</button>
                <button id="custom-modal-cancel-btn" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>
    
    <input type="file" id="json-file-input" class="hidden" accept=".json">


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { 
            getAuth, onAuthStateChanged, signOut, 
            createUserWithEmailAndPassword, signInWithEmailAndPassword,
            GoogleAuthProvider, signInWithPopup,
            signInWithCustomToken, signInAnonymously
        } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, collection, addDoc, deleteDoc, updateDoc, getDocs, getDoc, setDoc, setLogLevel, serverTimestamp, query, where, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "YOUR_API_KEY", authDomain: "...", projectId: "..." };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-tangent-rpg-app';

        // --- Firebase Initialization ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // --- Application State ---
        const appState = {
            userId: null,
            isAnonymous: true,
            currentCollection: null,
            currentSubcollection: null,
            editingDocId: null,
            confirmCallback: null,
            initialFormState: null,
            pendingNavigation: null,
            navigationContext: null,
            currentFolioData: null,
            activeFormForLoad: null,
            activeEquipmentTab: 'armoring',
            navigationHistory: [],
            currentView: null,
            searchTerm: '',
            sortBy: 'name',
            sortDirection: 'asc',
            wikiEntries: [], // Store all wiki entries for directory and linking
            currentWikiEntryId: null, // Track the currently displayed wiki entry
        };

        // --- RPG System Configuration ---
        const categoryConfig = {
            other: {
                label: 'DASHBOARD',
                viewType: 'button_grid'
            },
            persona_folio: {
                label: 'PERSONA FOLIO',
                viewType: 'character_sheet',
                fields: {
                    'char-name': { type: 'text' },
                    'char-concept': { type: 'text' },
                    'char-species': { type: 'text', source: 'species' },
                    'char-occu': { type: 'text', source: 'occupations' },
                    'char-origin': { type: 'text', source: 'origins' },
                    'char-faction': { type: 'text', source: 'factions' },
                    'char-age': { type: 'text' },
                    'char-gender': { type: 'text' },
                    'char-height': { type: 'text' },
                    'char-weight': { type: 'text' },
                    'char-style': { type: 'textarea' },
                    'char-motive': { type: 'textarea' },
                    'attr-strength': { type: 'number' },
                    'attr-agility': { type: 'number' },
                    'attr-constitution': { type: 'number' },
                    'attr-intellect': { type: 'number' },
                    'attr-wisdom': { type: 'number' },
                    'attr-charisma': { type: 'number' },
                    'health': { type: 'number' },
                    'vitality': { type: 'number' },
                    'karma': { type: 'number' },
                    'plot-points': { type: 'number' },
                    'wealth': { type: 'text' },
                    'features': { type: 'json_list', source: 'features' },
                    'disadvantages': { type: 'json_list', source: 'disadvantages' },
                    'augmentations': { type: 'json_list', source: 'augmentations' },
                    'invocations': { type: 'json_list', source: 'invocations' },
                    'special_abilities': { type: 'json_list' },
                    'equipment': { type: 'json_list', source: 'equipment' },
                    'associates': { type: 'json_list', source: 'associates' },
                    'attacks': { type: 'json_list' },
                    'armor': { type: 'json_list' },
                    'notes': { type: 'json_list' },
                }
            },
            rules_codex: {
                label: 'RULES CODEX',
                viewType: 'wiki', // Changed to wiki view
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    mechanic: { type: 'textarea' }, // Added mechanic field
                    note: { type: 'textarea' },
                    guide: { type: 'textarea' }, // New guide field
                    parent: { type: 'select', source: 'rules_codex', label: 'Parent Entry', manageable: false }, // For tree structure
                    order: { type: 'number', label: 'Order', default: 0 }, // For manual sorting
                }
            },
            values: {
                label: 'VALUES',
                hideFromMenu: true,
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    mechanic: { type: 'textarea' },
                    cp: { type: 'number' }
                }
            },
            secondary_values: {
                label: 'SECONDARY VALUES',
                hideFromMenu: true,
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    mechanic: { type: 'textarea' },
                    cp: { type: 'number' }
                }
            },
            tertiary_values: {
                label: 'TERTIARY VALUES',
                hideFromMenu: true,
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    mechanic: { type: 'textarea' },
                    cp: { type: 'number' }
                }
            },
            species: { 
                label: 'SPECIES',
                directory_columns: ['name', 'description', 'type'],
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    type: { type: 'multiselect', source: 'species_type', manageable: true },
                    size: { type: 'multiselect', source: 'species_size', manageable: true },
                    movement: { type: 'multiselect', source: 'species_movement', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    note: { type: 'textarea' },
                    cp: { type: 'readonlytext', label: 'CP' }
                },
                subcategories: {
                    species_type: { 
                        label: 'TYPES', 
                        directory_columns: ['name', 'description', 'modifier'],
                        fields: { 
                            name: { type:'text', required: true},
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            description: { type:'textarea', aiEnabled: true}, 
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' },
                            cp: { type: 'readonlytext', label: 'TOTAL CP'} 
                        } 
                    },
                    species_size: { 
                        label: 'SIZES', 
                        directory_columns: ['name', 'description', 'modifier'],
                        fields: { 
                            name: { type:'text', required: true},
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            description: { type:'textarea', aiEnabled: true}, 
                            scaling: { type: 'number', label: 'Scaling' },
                            height_length_range: { type: 'text', label: 'Height/Length Range' },
                            weight_range: { type: 'text', label: 'Weight Range' },
                            reach: { type: 'text', label: 'Reach' },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            cp: { type: 'readonlytext', label: 'TOTAL CP'} 
                        } 
                    },
                    species_movement: { 
                        label: 'MOVEMENTS', 
                        directory_columns: ['name', 'description', 'cp'],
                        fields: { 
                            name: { type:'text', required: true}, 
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            description: { type:'textarea', aiEnabled: true},
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' },
                            cp: { type: 'readonlytext', label: 'TOTAL CP' } 
                        } 
                    },
                }
            },
            factions: { 
                label: 'FACTIONS', 
                directory_columns: ['name', 'description'],
                fields: { 
                    name: { type:'text', required: true}, 
                    description: { type:'textarea', aiEnabled: true },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    attitude: { type: 'textarea' },
                    goals: { type: 'textarea' },
                    social_strengths: { type: 'textarea' },
                    social_weaknesses: { type: 'textarea' },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                } 
            },
            origins: { 
                label: 'ORIGINS', 
                directory_columns: ['name', 'description'],
                fields: { 
                    name: { type:'text', required: true}, 
                    description: { type:'textarea', aiEnabled: true},
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    trait: { type: 'multiselect', source: 'trait', manageable: true },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                },
                subcategories: {
                    trait: { 
                        label: 'TRAITS', 
                        directory_columns: ['name', 'description', 'cp'],
                        fields: { 
                            name: { type:'text', required: true}, 
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                            meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            description: { type:'textarea', aiEnabled: true}, 
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' },
                            cp: { type: 'readonlytext', label: 'TOTAL CP' } 
                        } 
                    },
                }
            },
            occupations: { 
                label: 'OCCUPATIONS',
                directory_columns: ['name', 'description'],
                fields: { 
                    name: { type:'text', required: true}, 
                    description: { type:'textarea', aiEnabled: true},
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    trait: { type: 'multiselect', source: 'trait', manageable: true },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                } 
            },
            disadvantages: { 
                label: 'DISADVANTAGES',
                directory_columns: ['name', 'description', 'cp'],
                fields: { 
                    name: { type:'text', required: true}, 
                    description: { type:'textarea', aiEnabled: true},
                    tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                    meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    cp: { type: 'number'},
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                } 
            },
            features: { 
                label: 'FEATURES',
                directory_columns: ['name', 'type', 'description', 'cp'], 
                fields: { 
                    name: { type:'text', required: true},
                    type: { type: 'select', options: ['ability', 'combat', 'meta', 'general', 'karma', 'skill', 'special'] },
                    description: { type:'textarea', aiEnabled: true},
                    tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                    meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true},
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    cp: { type: 'readonlytext', label: 'TOTAL CP' },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                } 
            },
            skills: { 
                label: 'SKILLS',
                directory_columns: ['name', 'type', 'subtype', 'description'],
                fields: { 
                    name: { type:'text', required: true},
                    type: { type: 'select', options: ['mental', 'physical', 'social', 'combat', 'meta'], required: true },
                    subtype: { type: 'select' },
                    is_specialization: { type: 'boolean', label: 'SPECIALIZATION' },
                    base_skill: { type: 'select', source: 'skills', label: 'BASE SKILL' },
                    description: { type:'textarea', aiEnabled: true},
                    tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                    meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                } 
            },
            prerequisite: {
                label: 'PREREQUISITES',
                hideFromMenu: true,
                directory_columns: ['name', 'aspect', 'aspect_subtype', 'value', 'note', 'cp'],
                fields: {
                    name: { type: 'text', required: true},
                    description: { type: 'textarea', aiEnabled: true},
                    aspect: { type: 'select', options: ['attribute', 'skill', 'combat', 'meta', 'other'] },
                    aspect_subtype: { type: 'select' },
                    value: { type: 'number' },
                    dc: { type: 'number', label: 'DC' },
                    mechanic: { type: 'textarea'},
                    note: { type: 'textarea'},
                    cp: { type: 'number' }
                }
            },
            modifier: {
                label: 'MODIFIERS',
                hideFromMenu: true,
                directory_columns: ['name', 'aspect', 'aspect_subtype', 'value', 'note', 'cp'],
                fields: {
                    name: { type: 'text', required: true},
                    description: { type: 'textarea', aiEnabled: true},
                    aspect: { type: 'select', options: ['attribute', 'skill', 'combat', 'meta', 'other'] },
                    aspect_subtype: { type: 'select' },
                    value: { type: 'number' },
                    modifier_type: { type: 'radio', label: 'Modifier Type', options: ['constant', 'situational', 'optional', 'temporary'] },
                    dc: { type: 'number', label: 'DC' },
                    mechanic: { type: 'textarea'},
                    note: { type: 'textarea'},
                    cp: { type: 'number' }
                }
            },
            augmentations: { 
                label: 'AUGMENTATIONS', 
                directory_columns: ['name', 'type', 'description', 'design_dc'],
                fields: { 
                    name: { type:'text', required: true},
                    type: { type: 'select', source: 'augmentation_type', manageable: true },
                    classification: { type: 'multiselect', source: 'classification', manageable: true, label: 'Classification' },
                    location: { type: 'multiselect', source: 'body_location', manageable: true },
                    description: { type:'textarea', aiEnabled: true},
                    tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                    meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                    creator: { type: 'multiselect', source: 'creator', manageable: true },
                    design: { type: 'multiselect', source: 'design', manageable: true },
                    component: { type: 'multiselect', source: 'component', manageable: true },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true},
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    critical_success_effect: { type: 'multiselect', source: 'critical_success_effect', manageable: true },
                    critical_failure_effect: { type: 'multiselect', source: 'critical_failure_effect', manageable: true },
                    cost: { type: 'number', label: 'Cost' },
                    availability: { type: 'select', source: 'availability', manageable: true },
                    cr: { type: 'number', label: 'CR' },
                    restricted: { type: 'boolean', label: 'Restricted' },
                    design_dc: { type: 'readonlytext', label: 'DESIGN DC' },
                    cp: { type: 'number' },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                },
                subcategories: {
                    augmentation_type: { 
                        label: 'AUGMENTATION TYPES', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    }
                }
            },
            invocations: {
                label: 'INVOCATIONS',
                directory_columns: ['name', 'description', 'discipline', 'meta_skill', 'design_dc'],
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    discipline: { type: 'select', source: 'discipline', manageable: true },
                    meta_skill: { type: 'select', source: 'skills_meta', label: 'Meta Skill' },
                    area: { type: 'multiselect', source: 'area', manageable: true },
                    effect: { type: 'multiselect', source: 'effect', manageable: true },
                    range: { type: 'multiselect', source: 'range', manageable: true },
                    target: { type: 'multiselect', source: 'target', manageable: true },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    critical_success_effect: { type: 'multiselect', source: 'critical_success_effect', manageable: true },
                    critical_failure_effect: { type: 'multiselect', source: 'critical_failure_effect', manageable: true },
                    design_dc: { type: 'readonlytext', label: 'DESIGN DC' },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                },
                subcategories: {
                    discipline: { 
                        label: 'DISCIPLINES', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    }
                }
            },
            equipment: { 
                label: 'EQUIPMENT', 
                viewType: 'multi-table',
                tables: {
                    armoring: {
                        label: 'Armoring',
                        directory_columns: ['name', 'tl', 'ml', 'description', 'cost', 'design_dc'],
                        fields: {
                            name: { type: 'text', required: true, label: 'Armor Name' },
                            description: { type: 'textarea' },
                            tl: { type: 'number', label: 'TL' },
                            ml: { type: 'number', label: 'ML' },
                            cost: { type: 'number' },
                            availability: { type: 'select', source: 'availability', manageable: true },
                            design_dc: { type: 'readonlytext', label: 'DESIGN DC' },
                            size: { type: 'multiselect', source: 'species_size', manageable: true },
                            weight: { type: 'number' },
                            quality: { type: 'select', options: ['Bad', 'Poor', 'Standard', 'Good', 'Exceptional', 'Mastercrafted'] },
                            durability: { type: 'number' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            skill: { type: 'select', source: 'skills', manageable: true },
                            origin: { type: 'multiselect', source: 'origins', manageable: true },
                            creator: { type: 'multiselect', source: 'creator', manageable: true },
                            design: { type: 'multiselect', source: 'design', manageable: true },
                            classification: { type: 'multiselect', source: 'classification', manageable: true, label: 'Classification' },
                            material: { type: 'multiselect', source: 'material', manageable: true },
                            location: { type: 'multiselect', source: 'body_location', manageable: true },
                            component: { type: 'multiselect', source: 'component', manageable: true },
                            resistance: { type: 'multiselect', source: 'resistance', manageable: true },
                            critical_success_effect: { type: 'multiselect', source: 'critical_success_effect', manageable: true },
                            critical_failure_effect: { type: 'multiselect', source: 'critical_failure_effect', manageable: true },
                            component_slots: { type: 'number', label: 'Component Slots' },
                            modes: { type: 'multiselect', source: 'mode', manageable: true, label: 'Modes' },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    weaponry: {
                        label: 'Weaponry',
                        directory_columns: ['name', 'tl', 'ml', 'description', 'cost', 'design_dc'],
                        fields: {
                            name: { type: 'text', required: true, label: 'Weapon Name' },
                            description: { type: 'textarea' },
                            tl: { type: 'number', label: 'TL' },
                            ml: { type: 'number', label: 'ML' },
                            cost: { type: 'number' },
                            availability: { type: 'select', source: 'availability', manageable: true },
                            design_dc: { type: 'readonlytext', label: 'DESIGN DC' },
                            size: { type: 'multiselect', source: 'species_size', manageable: true },
                            weight: { type: 'number' },
                            quality: { type: 'select', options: ['Bad', 'Poor', 'Standard', 'Good', 'Exceptional', 'Mastercrafted'] },
                            durability: { type: 'number' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            skill: { type: 'select', source: 'skills', manageable: true },
                            special: { type: 'multiselect', source: 'special', manageable: true, label: 'Special' },
                            area: { type: 'multiselect', source: 'area', manageable: true },
                            effect: { type: 'multiselect', source: 'effect', manageable: true },
                            range: { type: 'multiselect', source: 'range', manageable: true },
                            target: { type: 'multiselect', source: 'target', manageable: true },
                            origin: { type: 'multiselect', source: 'origins', manageable: true },
                            creator: { type: 'multiselect', source: 'creator', manageable: true },
                            design: { type: 'multiselect', source: 'design', manageable: true },
                            classification: { type: 'multiselect', source: 'classification', manageable: true, label: 'Classification' },
                            accuracy: { type: 'number' },
                            ap: { type: 'number', label: 'AP' },
                            modes: { type: 'multiselect', source: 'mode', manageable: true, label: 'Modes' },
                            attack_rate: { type: 'text', label: 'Rate of Fire' },
                            critical_score: { type: 'text', label: 'Critical Score' },
                            critical_effect: { type: 'multiselect', source: 'critical_effect', manageable: true },
                            critical_success_effect: { type: 'multiselect', source: 'critical_success_effect', manageable: true },
                            critical_failure_effect: { type: 'multiselect', source: 'critical_failure_effect', manageable: true },
                            wielding: { type: 'select', options: ['One-Handed', 'Two-Handed', 'Versatile', 'Independent', 'Mounted'] },
                            component: { type: 'multiselect', source: 'component', manageable: true },
                            component_slots: { type: 'number', label: 'Component Slots' },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    mecha: {
                        label: 'Mecha',
                        directory_columns: ['name', 'tl', 'ml', 'description', 'cost', 'design_dc'],
                        fields: {
                            name: { type: 'text', required: true, label: 'Mecha Name' },
                            description: { type: 'textarea' },
                            tl: { type: 'number', label: 'TL' },
                            ml: { type: 'number', label: 'ML' },
                            cost: { type: 'number' },
                            availability: { type: 'select', source: 'availability', manageable: true },
                            design_dc: { type: 'readonlytext', label: 'DESIGN DC' },
                            size: { type: 'multiselect', source: 'species_size', manageable: true },
                            height: { type: 'number' },
                            weight: { type: 'number' },
                            quality: { type: 'select', options: ['Bad', 'Poor', 'Standard', 'Good', 'Exceptional', 'Mastercrafted'] },
                            durability: { type: 'number' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            skill: { type: 'select', source: 'skills', manageable: true },
                            origin: { type: 'multiselect', source: 'origins', manageable: true },
                            creator: { type: 'multiselect', source: 'creator', manageable: true },
                            design: { type: 'multiselect', source: 'design', manageable: true },
                            classification: { type: 'multiselect', source: 'classification', manageable: true, label: 'Classification' },
                            personnel: { type: 'text' },
                            cargo: { type: 'text' },
                            speed: { type: 'text' },
                            maneuverability: { type: 'text' },
                            control: { type: 'select', options: ['Auto', 'Remote', 'Pilot', 'Crew'] },
                            component: { type: 'multiselect', source: 'component', manageable: true },
                            critical_success_effect: { type: 'multiselect', source: 'critical_success_effect', manageable: true },
                            critical_failure_effect: { type: 'multiselect', source: 'critical_failure_effect', manageable: true },
                            component_slots: { type: 'number', label: 'Component Slots' },
                            modes: { type: 'multiselect', source: 'mode', manageable: true, label: 'Modes' },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    }
                },
                subcategories: {
                    availability: { 
                        label: 'AVAILABILITY', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    material: { 
                        label: 'MATERIALS', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' }, 
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    resistance: { 
                        label: 'RESISTANCES', 
                        directory_columns: ['name', 'type', 'value', 'description'],
                        fields: { 
                            name: { type: 'text', required: true },
                            type: { type: 'select', source: 'resistance_type', manageable: true },
                            value: { type: 'number' },
                            description: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    resistance_type: { 
                        label: 'RESISTANCE TYPES', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' }
                        }
                    },
                    special: { 
                        label: 'SPECIAL',
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        } 
                    },
                    mode: { 
                        label: 'MODES', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    critical_effect: { 
                        label: 'CRITICAL EFFECTS', 
                        fields: { 
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' },
                            effect: { type: 'multiselect', source: 'effect', manageable: true },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    component: { 
                        label: 'COMPONENTS',
                        directory_columns: ['name', 'description', 'cost'],
                        fields: {
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' },
                            equipment: { type: 'multiselect', source: 'all_equipment', label: 'Equipment', manageable: true },
                            cost: { type: 'number' }
                        }
                    },
                    creator: {
                        label: 'CREATORS',
                        directory_columns: ['name', 'description'],
                        fields: {
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    design: {
                        label: 'DESIGNS',
                        directory_columns: ['name', 'description'],
                        fields: {
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    classification: { 
                        label: 'CLASSIFICATIONS', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' }, 
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' } 
                        }
                    },
                    gear_category: { 
                        label: 'CATEGORIES', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    body_location: { 
                        label: 'BODY LOCATIONS', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    }
                }
            },
            societies: { 
                label: 'SOCIETIES', 
                directory_columns: ['name', 'description', 'tech_level', 'meta_level'],
                fields: { 
                    name: { type:'text', required: true}, 
                    description: { type:'textarea', aiEnabled: true},
                    tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                    meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    agriculture: { type: 'multiselect', source: 'society_agriculture', manageable: true },
                    architecture: { type: 'multiselect', source: 'society_architecture', manageable: true },
                    biotechnology: { type: 'multiselect', source: 'society_biotechnology', manageable: true },
                    commerce: { type: 'multiselect', source: 'society_commerce', manageable: true },
                    communication: { type: 'multiselect', source: 'society_communication', manageable: true },
                    devices: { type: 'multiselect', source: 'society_devices', manageable: true },
                    education: { type: 'multiselect', source: 'society_education', manageable: true },
                    energy: { type: 'multiselect', source: 'society_energy', manageable: true },
                    manufacturing: { type: 'multiselect', source: 'society_manufacturing', manageable: true },
                    materials: { type: 'multiselect', source: 'society_materials', manageable: true },
                    medicine: { type: 'multiselect', source: 'society_medicine', manageable: true },
                    synthetics: { type: 'multiselect', source: 'society_synthetics', manageable: true, label: 'Synthetics' },
                    weaponry: { type: 'multiselect', source: 'society_weaponry', manageable: true },
                    mechanic: { type: 'textarea'},
                    note: { type: 'textarea'}
                },
                subcategories: {
                    society_agriculture: { label: 'AGRICULTURE', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text', required: true }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_architecture: { label: 'ARCHITECTURE', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text', required: true }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_biotechnology: { label: 'BIOTECHNOLOGY', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text', required: true }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_commerce: { label: 'COMMERCE', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text', required: true }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_communication: { label: 'COMMUNICATION', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_devices: { label: 'DEVICES', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_education: { label: 'EDUCATION', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_energy: { label: 'ENERGY', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_manufacturing: { label: 'MANUFACTURING', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_materials: { label: 'MATERIALS', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_medicine: { label: 'MEDICINE', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_society: { label: 'SOCIETY', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_synthetics: { label: 'SYNTHETICS', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_weaponry: { label: 'WEAPONRY', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }}}
            }
        };

        // --- Field Order Configuration ---
        const masterFieldOrder = [
            'name', 'description', 'mechanic', 'guide', 'effect_type', 'value', 'shape', 'dimensions', 'number_of_targets', /* Added 'guide' */
            'tech_level', 'meta_level', 'class', 'classification', 'category', 'type', 'subtype',
            'cr', 'cost', 'availability', 'dc', 'cp', 'restricted', 'component_slots',
            'location', 'size', 'height', 'weight', 'scaling', 'height_length_range', 'weight_range', 'personnel', 'cargo', 'reach', 'weapon_effect', 'wielding',
            'movement', 'speed',
            'quality', 'material', 'durability', 'resistance',
            'prerequisite', 'modifier', 'modifier_type', 'abilities',
            'ammunition_type', 'ap', 'area', 'attack_rate', 'damage', 'damage_type', 'damage_value', 'effect', 'effect_subtype', 'range', 'target', 'critical_score', 'critical_success_effect', 'critical_failure_effect', 'critical_effect',
            'skill', 'meta_skill', 'faction_skill', 'profession_skill', 'species_skill', 'is_specialization', 'base_skill', 'discipline', 'accuracy', 'control', 'maneuverability',
            'faction_feat', 'recommended_feature',
            'trait',
            'attitude', 'social_strengths', 'social_weaknesses', 'society', 'value', 'goals',
            'component', 'integration',
            'special',
            'modes', 'note', 'parent', 'order' 
        ];
        
        // --- UI Elements ---
        const mainContentContainer = document.getElementById('main-content');
        const entryModal = document.getElementById('entry-modal');
        const modalTitle = document.getElementById('modal-title');
        const entryForm = document.getElementById('entry-form');
        const formFieldsContainer = document.getElementById('form-fields');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');
        const confirmOkBtn = document.getElementById('confirm-ok-btn');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
        const unsavedChangesModal = document.getElementById('unsaved-changes-modal');
        const unsavedCancelBtn = document.getElementById('unsaved-cancel-btn');
        const unsavedDismissBtn = document.getElementById('unsaved-dismiss-btn');
        const unsavedSaveBtn = document.getElementById('unsaved-save-btn');
        const errorModal = document.getElementById('error-modal');
        const errorMessage = document.getElementById('error-message');
        const errorOkBtn = document.getElementById('error-ok-btn');
        const helpModal = document.getElementById('help-modal');
        const helpContent = document.getElementById('help-content');
        const helpCloseBtn = document.getElementById('help-close-btn');
        const customModal = document.getElementById('custom-modal');
        const summaryModal = document.getElementById('summary-modal');
        const summaryCloseBtn = document.getElementById('summary-close-btn');
        const jsonFileInput = document.getElementById('json-file-input');

        // --- Authentication & Navigation---
        let currentRenderFn = null;
        
        function navigateTo(renderFn, pushState = true) {
            if (pushState && currentRenderFn) {
                if (appState.navigationHistory.length === 0 || appState.navigationHistory[appState.navigationHistory.length - 1].toString() !== currentRenderFn.toString()) {
                    appState.navigationHistory.push(currentRenderFn);
                }
            }
            currentRenderFn = renderFn;
            renderFn();
        }

        function goBack() {
            if (appState.navigationHistory.length > 0) {
                const previousRenderFn = appState.navigationHistory.pop();
                navigateTo(previousRenderFn, false);
            } else {
                navigateTo(() => renderCategoryView('other'), false);
            }
        }

        let initialAuthAttempted = false;
        async function handleAuthentication() {
            initialAuthAttempted = true;
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                try {
                    await signInAnonymously(auth);
                } catch (anonError) {
                    console.error("Anonymous sign-in also failed:", anonError);
                    showError("Could not authenticate. Please refresh the page.");
                }
            }
        }

        onAuthStateChanged(auth, (user) => {
            if (user) {
                appState.userId = user.uid;
                appState.isAnonymous = user.isAnonymous;
                // Populate rulesCodexMap after authentication
                populateRulesCodexMap();
                if (!currentRenderFn) {
                    navigateTo(() => renderCategoryView('other'));
                }
            } else if (!initialAuthAttempted) {
                handleAuthentication();
            }
        });

        
        function getFormDataObject(formElement) {
            const form = formElement || document.getElementById('entry-form');
            if (!form) return {};
            const formData = new FormData(form);
            const data = {};
            for (let [key, value] of formData.entries()) {
                if (data[key]) {
                    if (!Array.isArray(data[key])) {
                        data[key] = [data[key]];
                    }
                    data[key].push(value);
                } else {
                    data[key] = value;
                }
            }
            return data;
        }
        
        function getFormState(form) {
            return JSON.stringify(getFormDataObject(form));
        }

        function isFormDirty() {
            if (appState.initialFormState === null) return false;
             if (appState.currentCollection === 'persona_folio') {
                return appState.initialFormState !== JSON.stringify(getPersonaFolioFormData());
            }
            return appState.initialFormState !== getFormState(document.getElementById('entry-form'));
        }

        function handleManageClick(sourceKey) {
            appState.navigationContext = {
                from: 'modal',
                parentCollection: appState.currentCollection,
                parentSubcollection: appState.currentSubcollection,
                docId: appState.editingDocId,
                data: getFormDataObject(document.getElementById('entry-form'))
            };

            const navigateToManagementView = () => {
                const parentForSource = Object.keys(categoryConfig).find(key => 
                    (categoryConfig[key].subcategories && categoryConfig[key].subcategories[sourceKey])
                ) || sourceKey;

                const isSubcategory = !!(categoryConfig[parentForSource]?.subcategories?.[sourceKey]);
                
                if (isSubcategory || categoryConfig[sourceKey]) {
                    navigateTo(() => renderManagementView(sourceKey, parentForSource));
                } else {
                    appState.currentSubcollection = null; 
                    navigateTo(() => renderManagementView(sourceKey, appState.navigationContext.parentCollection));
                }
            };

            requestNavigation(navigateToManagementView, true);
        }

        function handleNavigateToEquipment() {
            requestNavigation(() => navigateTo(() => renderCategoryView('equipment')));
        }
        window.handleNavigateToEquipment = handleNavigateToEquipment;
        
        // --- Navigation & View Rendering ---

        function requestNavigation(navigationFunc, force = false) {
            const isModalOpen = !entryModal.classList.contains('hidden');
            const activeForm = isModalOpen ? document.getElementById('entry-form') : document.getElementById('persona-folio-form');
            let isDirty = false;
            
            if(activeForm && activeForm.id === 'entry-form'){
                isDirty = isFormDirty();
            } else if (activeForm && activeForm.id === 'persona-folio-form') {
                 isDirty = appState.initialFormState !== JSON.stringify(getPersonaFolioFormData());
            }

            if (force || !isDirty ) {
                closeModal(true); // Pass the force flag here
                if (navigationFunc) {
                    navigationFunc();
                }
            } else {
                appState.pendingNavigation = navigationFunc;
                unsavedChangesModal.classList.remove('hidden');
            }
        }
        
        function renderAppHeader(activeCategoryKey) {
            const headerContainer = document.createElement('header');
            headerContainer.className = 'app-header flex justify-between items-center gap-4';

            const leftCol = document.createElement('div');
            leftCol.className = 'flex-1';
            
            const dropdownContainer = document.createElement('div');
            dropdownContainer.className = 'relative';

            const menuButton = document.createElement('button');
            menuButton.id = 'category-menu-button';
            menuButton.className = 'category-menu-button font-bold py-1 px-2 rounded-lg inline-flex items-center w-full max-w-xs justify-between';
            menuButton.innerHTML = `
                <span>${categoryConfig[activeCategoryKey].label.toUpperCase()}</span>
            `;

            const dropdownMenu = document.createElement('div');
            dropdownMenu.id = 'category-dropdown-menu';
            dropdownMenu.className = 'category-dropdown-menu hidden absolute left-0 mt-2 w-auto min-w-max rounded-md shadow-lg z-20 whitespace-nowrap';
            
            const dropdownList = document.createElement('div');
            dropdownList.className = 'py-1';

            // "Dashboard" Link first
            const dashboardLink = document.createElement('a');
            dashboardLink.href = '#';
            dashboardLink.className = 'block px-4 py-2 text-sm text-gray-300 hover:text-white font-bold';
            dashboardLink.textContent = 'DASHBOARD';
            dashboardLink.onclick = (e) => {
                e.preventDefault();
                requestNavigation(() => navigateTo(() => renderCategoryView('other')));
                dropdownMenu.classList.add('hidden');
            };
            dropdownList.appendChild(dashboardLink);

            const mainCategories = Object.keys(categoryConfig).filter(key => !categoryConfig[key].hideFromMenu && key !== 'other');
            
            mainCategories.forEach(key => {
                const link = document.createElement('a');
                link.href = '#';
                link.className = 'block px-4 py-2 text-sm text-gray-300 hover:text-white';
                link.textContent = categoryConfig[key].label.toUpperCase();
                link.onclick = (e) => {
                    e.preventDefault();
                    requestNavigation(() => navigateTo(() => renderCategoryView(key)));
                    dropdownMenu.classList.add('hidden');
                };
                dropdownList.appendChild(link);
            });


            dropdownMenu.appendChild(dropdownList);

            menuButton.onclick = () => {
                dropdownMenu.classList.toggle('hidden');
            };
            
            dropdownContainer.appendChild(menuButton);
            dropdownContainer.appendChild(dropdownMenu);
            leftCol.appendChild(dropdownContainer);
            headerContainer.appendChild(leftCol);

            const centerCol = document.createElement('div');
            centerCol.className = 'text-center px-4';
            centerCol.innerHTML = `
                <h1 class="text-xl font-bold text-gray-100 whitespace-nowrap">TANGENT SFF RPG</h1>
                <p class="text-xs text-gray-400 uppercase">DATABASE MANAGER</p>`;
            headerContainer.appendChild(centerCol);
            
            const rightCol = document.createElement('div');
            rightCol.className = 'flex-1 flex justify-end items-center gap-4';
            
            const userIdDiv = document.createElement('div');
            userIdDiv.className = 'text-right';
            userIdDiv.innerHTML = `
                <p class="text-xs text-gray-500">USER ID:</p>
                <p id="userIdDisplay" class="text-sm font-semibold bg-gray-700 rounded-md px-2 py-0.5 inline-block break-all" style="color: var(--text-subtle); background-color: var(--bg-header);">${appState.userId || ''}</p>
            `;
            rightCol.appendChild(userIdDiv);

            const guideButton = document.createElement('button'); /* Renamed helpButton to guideButton */
            guideButton.id = 'guide-btn'; /* Changed ID to guide-btn */
            guideButton.className = 'p-1 rounded-full hover:bg-gray-700 transition-colors underline';
            guideButton.textContent = "Guide"; /* Changed text to Guide */
            guideButton.onclick = () => { helpModal.classList.remove('hidden'); };
            rightCol.appendChild(guideButton);

            headerContainer.appendChild(rightCol);
            
            mainContentContainer.appendChild(headerContainer);
        }

        // --- NEW/FIXED FUNCTIONS START ---

        function getSingularLabel(label) {
            if (!label) return '';
            label = label.toUpperCase();
            if (label.endsWith('IES')) return label.slice(0, -3) + 'Y';
            if (label.endsWith('S')) return label.slice(0, -1);
            return label;
        }

        function renderTableView(collectionKey, title, container, parentCategoryKey = null) {
            appState.currentCollection = parentCategoryKey || collectionKey;
            appState.currentSubcollection = parentCategoryKey ? collectionKey : null;

            container.innerHTML = `
                <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-6 gap-4">
                    <div class="flex items-center gap-4">
                         ${parentCategoryKey ? `<button id="back-btn" class="btn btn-secondary !p-2">&larr;</button>` : ''}
                        <h2 class="text-3xl font-bold truncate uppercase">${title}</h2>
                    </div>
                    <button id="add-new-entry-btn" class="btn btn-primary">Add New ${getSingularLabel(title)}</button>
                </div>
                <div class="shadow-lg rounded-lg overflow-x-auto">
                    <table class="data-table min-w-full">
                        <thead id="table-header-${collectionKey}">
                        </thead>
                        <tbody id="table-body-${collectionKey}">
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('add-new-entry-btn').onclick = () => {
                openModal();
            };
            
            if (parentCategoryKey) {
                document.getElementById('back-btn').onclick = () => {
                    navigateTo(() => renderCategoryView(parentCategoryKey));
                };
            }
        }

        function renderManagementView(collectionKey, parentKey) {
            appState.currentCollection = parentKey;
            appState.currentSubcollection = collectionKey;
            mainContentContainer.innerHTML = '';
            renderAppHeader(parentKey);

            const contentArea = document.createElement('div');
            contentArea.className = 'p-8 md:p-16 pt-24 md:pt-24';
            mainContentContainer.appendChild(contentArea);

            const config = getActiveConfig(collectionKey);
            renderTableView(collectionKey, config.label, contentArea, parentKey);
            listenForData(collectionKey);
        }

        function renderFolioDirectory(container) {
            container.innerHTML = `
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-3xl font-bold uppercase">Persona Folios</h2>
                    <button id="new-folio-btn" class="btn btn-primary">New Folio</button>
                </div>
                <div id="folio-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- Folio cards will be inserted here -->
                </div>
            `;

            document.getElementById('new-folio-btn').onclick = () => {
                // Navigate to the folio page with no ID to indicate a new character
                window.location.href = `persona_folio.html`;
            };

            listenForFolios();
        }

        function listenForFolios() {
            if (!appState.userId) return;

            const collectionPath = `artifacts/${appId}/public/data/persona_folio`;
            const q = query(collection(db, collectionPath), orderBy('char-name', 'asc'));

            onSnapshot(q, (snapshot) => {
                const folioListContainer = document.getElementById('folio-list');
                if (!folioListContainer) return;

                folioListContainer.innerHTML = '';
                if (snapshot.empty) {
                    folioListContainer.innerHTML = `<p class="text-gray-400 col-span-full text-center">No persona folios found. Create one to get started!</p>`;
                    return;
                }

                snapshot.forEach(doc => {
                    const folio = doc.data();
                    const docId = doc.id;
                    const card = document.createElement('div');
                    card.className = 'bg-gray-800 p-4 rounded-lg shadow-lg cursor-pointer hover:bg-gray-700 transition-all duration-200 transform hover:scale-105';
                    card.innerHTML = `
                        <h3 class="text-xl font-bold truncate">${folio['char-name'] || 'Unnamed Folio'}</h3>
                        <p class="text-sm text-gray-400 mt-2 h-10 overflow-hidden">${folio['char-concept'] ? folio['char-concept'].substring(0, 100) + (folio['char-concept'].length > 100 ? '...' : '') : 'No concept.'}</p>
                    `;
                    card.onclick = () => {
                        // Navigate to the folio page, passing the docId as a URL parameter
                        window.location.href = `persona_folio.html?id=${docId}`;
                    };
                    folioListContainer.appendChild(card);
                });
            }, error => {
                console.error("Error listening for folios:", error);
                showError("Failed to load persona folios.");
            });
        }
        
        // --- NEW/FIXED FUNCTIONS END ---

        function renderCategoryView(categoryKey) {
            appState.currentCollection = categoryKey;
            
            if (categoryKey !== 'equipment') {
                appState.activeEquipmentTab = 'armoring';
            }
            
            appState.currentSubcollection = null;
            mainContentContainer.innerHTML = ''; 
            
            renderAppHeader(categoryKey);

            const config = categoryConfig[categoryKey];
            const contentArea = document.createElement('div');
            contentArea.style.flexGrow = '1'; /* Ensure it fills space */

            if (categoryKey !== 'rules_codex' && categoryKey !== 'persona_folio') {
                /* Apply padding only for non-wiki views */
                contentArea.className = 'p-8 md:p-16 pt-24 md:pt-24';
            } else if (categoryKey === 'rules_codex') {
                /* For wiki view, contentArea will be the direct container for wiki-sidebar and wiki-content */
                /* No padding on contentArea itself here. */
                contentArea.style.display = 'flex'; /* Make it a flex container for sidebar and wiki-content */
                contentArea.style.flexDirection = 'row';
                contentArea.style.alignItems = 'stretch';
            } else if (categoryKey === 'persona_folio') {
                 contentArea.className = 'p-4 md:p-8';
            }
            mainContentContainer.appendChild(contentArea);
            
            if (config.viewType === 'character_sheet') {
                renderFolioDirectory(contentArea);
            } else if (config.viewType === 'multi-table') {
                renderMultiTableView(categoryKey, config, contentArea);
            } else if (config.viewType === 'button_grid') {
                renderButtonGridView(contentArea);
            } else if (config.viewType === 'wiki') { /* Handle new wiki view */
                renderWikiView(contentArea); // Pass contentArea to renderWikiView
            }
            else {
                renderTableView(categoryKey, config.label, contentArea);
                listenForData(collectionKey);
            }
        }

        function renderButtonGridView(container) {
            container.innerHTML = '<h2 class="text-3xl font-bold truncate uppercase mb-6">Dashboard</h2>';
            // Modified grid classes for more compact layout
            const grid = document.createElement('div');
            grid.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-3';
            
            // Modified combinedGroup and group padding
            const combinedGroup = document.createElement('div');
            combinedGroup.className = "border border-gray-600 p-3 rounded-lg flex flex-col gap-3";
            
            // Persona Folio Header
            const folioTitle = document.createElement('h3');
            folioTitle.className = 'text-xl font-bold uppercase cursor-pointer hover:underline text-left';
            folioTitle.textContent = categoryConfig['persona_folio'].label;
            folioTitle.onclick = () => {
                requestNavigation(() => navigateTo(() => renderCategoryView('persona_folio')));
            };
            combinedGroup.appendChild(folioTitle);
            
            // Rules Codex Header
            const rulesTitle = document.createElement('h3');
            rulesTitle.className = 'text-xl font-bold uppercase cursor-pointer hover:underline text-left';
            rulesTitle.textContent = categoryConfig['rules_codex'].label;
            rulesTitle.onclick = (e) => {
                e.preventDefault();
                requestNavigation(() => navigateTo(() => renderCategoryView('rules_codex')));
            };
            combinedGroup.appendChild(rulesTitle);

            grid.appendChild(combinedGroup);


            const categoriesToShow = ['species', 'factions', 'origins', 'occupations', 'disadvantages', 'features', 'skills', 'augmentations', 'invocations', 'equipment', 'societies'];

            categoriesToShow.forEach(parentKey => {
                const parentConfig = categoryConfig[parentKey];
                if (!parentConfig) return;

                const group = document.createElement('div');
                group.className = "border border-gray-600 p-3 rounded-lg flex flex-col"; /* Modified padding */

                const title = document.createElement('h3');
                title.className = 'text-xl font-bold uppercase cursor-pointer hover:underline text-left';
                title.textContent = parentConfig.label;
                title.onclick = () => {
                    requestNavigation(() => navigateTo(() => renderCategoryView(parentKey)));
                };
                group.appendChild(title);
                
                const subcatContainer = document.createElement('div');
                subcatContainer.className = 'mt-2 pl-4 border-l-2 border-gray-700 space-y-1';
                
                const allSubLinks = new Map();

                if (parentConfig.subcategories) {
                    for (const subcatKey in parentConfig.subcategories) {
                        allSubLinks.set(subcatKey, parentConfig.subcategories[subcatKey].label);
                    }
                }
                const allFields = {...(parentConfig.fields || {})};
                if(parentConfig.tables) {
                        Object.values(parentConfig.tables).forEach(table => {
                            Object.assign(allFields, table.fields);
                        });
                }
                for(const fieldKey in allFields) {
                    const field = allFields[fieldKey];
                    if (field.manageable && field.source && !allSubLinks.has(field.source)) {
                        const subConfig = getActiveConfig(field.source);
                        let label = subConfig ? subConfig.label : field.source.replace(/_/g, " ");
                        allSubLinks.set(field.source, label);
                    }
                }

                // Apply specific removals and renames
                if (parentKey === 'societies') {
                    allSubLinks.delete('society_society');
                    allSubLinks.delete('prerequisite');
                    allSubLinks.delete('modifier');
                }
                if (parentKey === 'equipment') {
                    allSubLinks.delete('resistance_type');
                    allSubLinks.delete('skills');
                    allSubLinks.delete('critical_effect');
                    allSubLinks.delete('special');
                }
                
                allSubLinks.delete('critical_success_effect');
                allSubLinks.delete('critical_failure_effect');

                let sortedKeys = Array.from(allSubLinks.keys());
                
                if (parentKey === 'species') {
                    const order = ['modifier', 'species_movement', 'species_size', 'species_type'];
                    sortedKeys = order.filter(key => allSubLinks.has(key));
                    const remaining = Array.from(allSubLinks.keys()).filter(k => !order.includes(k)).sort((a,b) => allSubLinks.get(a).localeCompare(allSubLinks.get(b)));
                    sortedKeys.push(...remaining);
                } else if (parentKey === 'equipment') {
                    const equipmentOrder = ['armoring', 'gear', 'mecha', 'weaponry'];
                    equipmentOrder.forEach(key => {
                        const tableConfig = parentConfig.tables[key];
                        if (tableConfig) {
                            subcatContainer.appendChild(createDashboardLink(key, tableConfig.label, parentKey, true));
                        }
                    });
                    const remainingKeys = Array.from(allSubLinks.keys()).filter(key => !equipmentOrder.includes(key) && key !== 'armor_class' && key !== 'skills');
                        if (subcatContainer.hasChildNodes() && remainingKeys.length > 0){
                            const hr = document.createElement('hr');
                            hr.className = 'border-gray-600 my-1';
                            subcatContainer.appendChild(hr);
                        }
                        remainingKeys.sort((a,b) => allSubLinks.get(a).localeCompare(allSubLinks.get(b))).forEach(key => {
                            subcatContainer.appendChild(createDashboardLink(key, allSubLinks.get(key), parentKey, false));
                        });
                        sortedKeys = []; 
                } else {
                    sortedKeys.sort((a,b) => allSubLinks.get(a).localeCompare(allSubLinks.get(b)));
                }

                sortedKeys.forEach(key => {
                    subcatContainer.appendChild(createDashboardLink(key, allSubLinks.get(key), parentKey));
                });

                if(subcatContainer.hasChildNodes()){
                        group.appendChild(subcatContainer);
                }
                
                grid.appendChild(group);
            });

            container.appendChild(grid);
        }

        function createDashboardLink(key, label, parentKey, isBold = false) {
            const link = document.createElement('a');
            link.href = '#';
            link.textContent = label.toUpperCase();
            link.className = `block text-sm hover:underline hover:text-white ${isBold ? 'text-gray-300 font-semibold' : 'text-gray-400'}`;
            link.onclick = (e) => {
                e.preventDefault(); e.stopPropagation();
                if (parentKey === 'equipment' && categoryConfig[parentKey].tables[key]) {
                    requestNavigation(() => navigateTo(() => renderCategoryView(parentKey)));
                    setTimeout(()=> {
                        document.querySelector(`button[data-tab-key='${key}']`)?.click();
                    }, 50);
                } else {
                    requestNavigation(() => navigateTo(() => renderManagementView(key, parentKey)));
                }
            };
            return link;
        }

        function renderMultiTableView(parentCategoryKey, config, container) {
            container.innerHTML = '';
            const tables = config.tables;
            for (const tableKey in tables) {
                const tableConfig = tables[tableKey];
                const tableContainer = document.createElement('div');
                tableContainer.className = 'mb-12';
                container.appendChild(tableContainer);
                renderTableView(tableKey, tableConfig.label, tableContainer, parentCategoryKey);
                listenForData(tableKey);
            }
        }

        function renderTabContent(tabKey, tabConfig, container) {
            appState.currentSubcollection = tabKey;
            
            container.innerHTML = '';
            const viewContainer = document.createElement('div');
            
            viewContainer.innerHTML = `
                <div class="flex flex-col sm:flex-row justify-between sm:items-center my-4 gap-4">
                    <div class="flex-grow min-w-0">
                        <h2 id="table-title-${tabKey}" class="text-3xl font-bold truncate uppercase cursor-pointer hover:underline">${tabConfig.label}</h2>
                    </div>
                </div>
                <div class="shadow-lg rounded-lg overflow-x-auto">
                    <table class="data-table min-w-full">
                        <thead id="table-header-${tabKey}">
                        </thead>
                        <tbody id="table-body-${tabKey}">
                        </tbody>
                    </table>
                </div>
            `;
            container.appendChild(viewContainer);
            document.getElementById(`table-title-${tabKey}`).onclick = () => {
                appState.currentSubcollection = tabKey;
                openModal();
            };
            
            listenForData(tabKey);
        }
        
        function renderWikiView(container) { /* `container` is now `contentArea` from renderCategoryView */
            container.innerHTML = `
                <div class="wiki-sidebar" id="wiki-sidebar">
                    <h3>Rules Codex</h3> <!-- Changed title here -->
                    <button id="add-wiki-entry-btn" class="btn btn-primary w-full mb-4">Add New Entry</button>
                    <ul id="wiki-directory-list"></ul>
                </div>
                <div class="wiki-content-area-wrapper"> <!-- New wrapper for main content and buttons -->
                    <div class="flex justify-end gap-2 mb-4"> <!-- Buttons here -->
                        <button id="wiki-edit-btn" class="btn btn-secondary" style="display:none;">Edit</button>
                        <button id="wiki-delete-btn" class="btn btn-danger" style="display:none;">Delete</button>
                    </div>
                    <div class="wiki-content" id="wiki-content">
                        <h2 id="wiki-entry-title">Select an Entry</h2>
                        <div id="wiki-entry-body">
                            <p class="text-gray-400">Please select an entry from the left sidebar or create a new one.</p>
                        </div>
                    </div>
                </div>
            `;

            const addEntryBtn = document.getElementById('add-wiki-entry-btn');
            addEntryBtn.onclick = () => {
                appState.currentCollection = 'rules_codex';
                appState.currentSubcollection = null;
                openModal(null, {}, true); // Open in edit mode for new entry
            };

            const wikiEditBtn = document.getElementById('wiki-edit-btn');
            const wikiDeleteBtn = document.getElementById('wiki-delete-btn');

            wikiEditBtn.onclick = () => {
                if (appState.currentWikiEntryId) {
                    const entry = appState.wikiEntries.find(e => e.id === appState.currentWikiEntryId);
                    if (entry) {
                        appState.currentCollection = 'rules_codex';
                        openModal(entry.id, entry, true); // Open in edit mode
                    }
                }
            };

            wikiDeleteBtn.onclick = () => {
                if (appState.currentWikiEntryId) {
                    deleteEntry(appState.currentWikiEntryId);
                }
            };

            listenForWikiEntries(); // Start listening for rules_codex data
        }

        async function renderWikiDirectory(container, entries, parent = null, level = 0) {
            const ul = document.createElement('ul');
            ul.className = `space-y-1 ${level > 0 ? 'wiki-tree-children' : ''}`;

            const children = entries.filter(entry => entry.parent === parent).sort((a, b) => (a.order || 0) - (b.order || 0) || a.name.localeCompare(b.name));

            for (const entry of children) {
                const li = document.createElement('li');
                const hasChildren = entries.some(e => e.parent === entry.name);

                const itemContent = document.createElement('div');
                itemContent.className = 'wiki-tree-item';

                let toggleBtn = '';
                if (hasChildren) {
                    toggleBtn = `<button class="toggle-btn" data-toggle-id="${entry.id}">&#9658;</button>`; // Right arrow
                } else {
                    toggleBtn = `<span class="toggle-btn"></span>`; // Placeholder for alignment
                }

                itemContent.innerHTML = `
                    ${toggleBtn}
                    <a href="#" class="wiki-tree-item-content" data-entry-id="${entry.id}">${entry.name}</a>
                `;
                li.appendChild(itemContent);

                if (hasChildren) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.id = `children-${entry.id}`;
                    childrenContainer.style.display = 'none'; // Hidden by default
                    childrenContainer.appendChild(await renderWikiDirectory(null, entries, entry.name, level + 1));
                    li.appendChild(childrenContainer);

                    const toggleButton = itemContent.querySelector('.toggle-btn');
                    toggleButton.onclick = () => {
                        const isHidden = childrenContainer.style.display === 'none';
                        childrenContainer.style.display = isHidden ? 'block' : 'none';
                        toggleButton.innerHTML = isHidden ? '&#9660;' : '&#9658;'; // Down or right arrow
                    };
                }

                const link = itemContent.querySelector('a');
                link.onclick = (e) => {
                    e.preventDefault();
                    displayWikiEntry(entry.id);
                };

                ul.appendChild(li);
            }
            if (container) {
                container.appendChild(ul);
            }
            return ul;
        }

        async function displayWikiEntry(docId) {
            const wikiContentDiv = document.getElementById('wiki-content');
            const wikiTitle = document.getElementById('wiki-entry-title');
            const wikiBody = document.getElementById('wiki-entry-body');
            const wikiEditBtn = document.getElementById('wiki-edit-btn');
            const wikiDeleteBtn = document.getElementById('wiki-delete-btn');

            wikiTitle.textContent = 'Loading...';
            wikiBody.innerHTML = '<p class="text-center text-gray-400">Loading entry...</p>';
            wikiEditBtn.style.display = 'none';
            wikiDeleteBtn.style.display = 'none';
            appState.currentWikiEntryId = null;

            try {
                const entry = appState.wikiEntries.find(e => e.id === docId);

                if (entry) {
                    wikiTitle.textContent = entry.name.toUpperCase();
                    let contentHtml = '';

                    if (entry.description) {
                        contentHtml += `<p>${parseWikiLinks(entry.description)}</p>`;
                    }
                    if (entry.mechanic) { /* Display mechanic field */
                        contentHtml += `<h3>Mechanics</h3><p>${parseWikiLinks(entry.mechanic)}</p>`;
                    }
                    if (entry.guide) { /* Display guide field */
                        contentHtml += `<h3>Guide</h3><p>${parseWikiLinks(entry.guide)}</p>`;
                    }
                    if (entry.note) {
                        contentHtml += `<h3>Notes</h3><p>${parseWikiLinks(entry.note)}</p>`;
                    }
                    if (!contentHtml) {
                        contentHtml = '<p class="text-gray-400">No content available for this entry.</p>';
                    }
                    wikiBody.innerHTML = contentHtml;
                    appState.currentWikiEntryId = docId;

                    // Show edit/delete buttons if the user is authenticated and not anonymous
                    if (appState.userId && !appState.isAnonymous) {
                        wikiEditBtn.style.display = 'inline-block';
                        wikiDeleteBtn.style.display = 'inline-block';
                    }

                } else {
                    wikiTitle.textContent = 'Entry Not Found';
                    wikiBody.innerHTML = '<p class="text-red-400">The requested wiki entry could not be found.</p>';
                }
            } catch (error) {
                console.error("Error displaying wiki entry:", error);
                showError("Failed to display wiki entry.");
                wikiTitle.textContent = 'Error';
                wikiBody.innerHTML = '<p class="text-red-400">An error occurred while loading the entry.</p>';
            }
        }
        window.displayWikiEntry = displayWikiEntry; // Make global for wiki links

        async function getCollectionOptions(collectionName) {
            if (collectionName === 'all_equipment') {
                const equipmentTypes = ['armoring', 'weaponry', 'mecha', 'gear'];
                let allOptions = [];
                for (const type of equipmentTypes) {
                    const options = await getCollectionOptions(type);
                    allOptions.push({ label: type.toUpperCase(), options });
                }
                return allOptions;
            }
            if (collectionName === 'skills_meta') {
                const allSkills = await getCollectionOptions('skills');
                const metaSkills = allSkills.filter(skill => skill.type === 'meta');
                return [{ name: 'Special Ability'}, ...metaSkills];
            }
            // For rules_codex as a source for 'parent' field
            if (collectionName === 'rules_codex') {
                // Ensure we don't list the current entry as its own parent
                const filteredEntries = appState.wikiEntries.filter(entry => entry.id !== appState.editingDocId);
                return filteredEntries.map(entry => ({ name: entry.name, id: entry.id }));
            }


            const collectionPath = `artifacts/${appId}/public/data/${collectionName}`;
            try {
                const querySnapshot = await getDocs(collection(db, collectionPath));
                return querySnapshot.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .sort((a,b) => (a.name || '').localeCompare(b.name || ''));
            } catch (error) {
                console.error(`Error getting options from ${collectionName}:`, error);
                showError(`Could not load options for ${collectionName}.`);
                return [];
            }
        }
        
        function getActiveConfig(collectionKey) {
            if (!collectionKey) return null;
            
            if (categoryConfig[collectionKey]) {
                return categoryConfig[collectionKey];
            }
            
            for (const mainKey in categoryConfig) {
                const mainConfig = categoryConfig[mainKey];
                if (mainConfig?.tables && mainConfig.tables[collectionKey]) {
                    return mainConfig.tables[collectionKey];
                }
                if (mainConfig?.subcategories?.[collectionKey]) {
                    return mainConfig.subcategories[collectionKey];
                }
            }
            return null;
        }

        // Global map to store rules codex entries for quick lookup
        let rulesCodexMap = new Map();

        // Function to fetch and populate rulesCodexMap
        async function populateRulesCodexMap() {
            const collectionPath = `artifacts/${appId}/public/data/rules_codex`;
            try {
                const querySnapshot = await getDocs(collection(db, collectionPath));
                rulesCodexMap.clear();
                appState.wikiEntries = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                appState.wikiEntries.forEach(entry => {
                    rulesCodexMap.set(entry.name, entry.id);
                });
                console.log("Rules Codex Map populated:", rulesCodexMap);

                // Re-render wiki directory after map is populated
                if (appState.currentCollection === 'rules_codex') {
                    const wikiSidebar = document.getElementById('wiki-directory-list');
                    if (wikiSidebar) {
                        wikiSidebar.innerHTML = '';
                        renderWikiDirectory(wikiSidebar, appState.wikiEntries);
                        // If no entry is selected, display the first one
                        if (!appState.currentWikiEntryId && appState.wikiEntries.length > 0) {
                            displayWikiEntry(appState.wikiEntries[0].id);
                        }
                    }
                }

            } catch (error) {
                console.error("Error populating Rules Codex Map:", error);
                showError("Could not load Rules Codex entries. Please check Firebase permissions.");
            }
        }

        // Function to listen for real-time updates to rules_codex
        function listenForWikiEntries() {
            if (!appState.userId) return; // Ensure user is authenticated

            const collectionPath = `artifacts/${appId}/public/data/rules_codex`;
            const q = query(collection(db, collectionPath));

            onSnapshot(q, (snapshot) => {
                appState.wikiEntries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                rulesCodexMap.clear();
                appState.wikiEntries.forEach(entry => {
                    rulesCodexMap.set(entry.name, entry.id);
                });

                const wikiSidebar = document.getElementById('wiki-directory-list');
                if (wikiSidebar) {
                    wikiSidebar.innerHTML = '';
                    renderWikiDirectory(wikiSidebar, appState.wikiEntries);
                    // If an entry was previously selected, re-display it to update links/content
                    if (appState.currentWikiEntryId) {
                        displayWikiEntry(appState.currentWikiEntryId);
                    } else if (appState.wikiEntries.length > 0) {
                        // If no entry was selected, display the first one
                        displayWikiEntry(appState.wikiEntries[0].id);
                    }
                }
            }, error => {
                console.error("Error listening for wiki entries:", error);
                showError("Failed to load wiki entries. Check console for details.");
            });
        }


        function createTableRow(docId, data, collectionKey) {
            const config = getActiveConfig(collectionKey);
            
            if (!config || !config.fields) {
                console.error("Could not find config for table row", collectionKey);
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="99" class="text-red-500">Config error for ${collectionKey}</td>`;
                return tr;
            }
            const fields = config.fields;
            const columnsToShow = config.directory_columns || Object.keys(fields);

            const tr = document.createElement('tr');
            tr.className = 'cursor-pointer';
            tr.dataset.id = docId;
            tr.onclick = () => {
                const parentConfigKey = Object.keys(categoryConfig).find(key => 
                    (categoryConfig[key].tables && categoryConfig[key].tables[collectionKey]) ||
                    (categoryConfig[key].subcategories && categoryConfig[key].subcategories[collectionKey])
                );

                if (parentConfigKey) {
                    appState.currentCollection = parentConfigKey;
                    appState.currentSubcollection = collectionKey;
                } else {
                    appState.currentCollection = collectionKey;
                    appState.currentSubcollection = null;
                }
                // Rules Codex entries open in read-only mode by default from table view
                const isRulesCodex = (collectionKey === 'rules_codex');
                openModal(docId, data, !isRulesCodex); // Pass isEditMode: true if not rules_codex, else false
            };

            columnsToShow.forEach(fieldKey => {
                const td = document.createElement('td');
                let value = data[fieldKey];
                td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-300 uppercase';
                
                if(fieldKey === 'is_specialization' || fieldKey === 'restricted') {
                    value = value === true || value === 'true' ? 'YES' : 'NO';
                } else if (fields[fieldKey]?.type === 'json_list' && typeof value === 'string' && value.startsWith('[')) {
                    try {
                        const parsed = JSON.parse(value);
                        value = parsed.map(p => `${p.name.toUpperCase()}: ${p.value}`).join(', ');
                    } catch (e) { /* Do nothing, display raw string if parse fails */ }
                }
                
                if(Array.isArray(value)) {
                    td.textContent = value.join(', ').toUpperCase();
                } else if (typeof value === 'object' && value !== null) {
                    td.textContent = JSON.stringify(value).toUpperCase();
                } else {
                    td.textContent = (value || '').toString().toUpperCase();
                }

                tr.appendChild(td);
            });
            return tr;
        }
        
        function listenForData(collectionName) {
            if (!appState.userId) return;

            const collectionPath = `artifacts/${appId}/public/data/${collectionName}`;
            let q = collection(db, collectionPath);

            if (appState.searchTerm) {
                const searchTermLower = appState.searchTerm.toLowerCase();
                q = query(q, where('name', '>=', searchTermLower), where('name', '<=', searchTermLower + '\uf8ff'));
            }
            q = query(q, orderBy(appState.sortBy, appState.sortDirection));

            
            const tableHeader = document.getElementById(`table-header-${collectionName}`);
            const tableBody = document.getElementById(`table-body-${collectionName}`);
            
            if (!tableHeader) return;
            tableHeader.innerHTML = '';
            const config = getActiveConfig(collectionName);
            if (!config || !config.fields) {
                console.error("Could not find config for table header", collectionName);
                return;
            }
            const fields = config.fields;
            const columnsToShow = config.directory_columns || Object.keys(fields);

            const tr = document.createElement('tr');
            columnsToShow.forEach(fieldKey => {
                const th = document.createElement('th');
                th.className = 'px-6 py-3 text-left text-xs font-bold tracking-wider';
                const fieldConfig = fields[fieldKey] || {};
                th.innerHTML = `<span>${(fieldConfig.label || fieldKey.replace(/_/g, ' ')).toUpperCase()}</span>`;
                th.dataset.sortKey = fieldKey;
                th.onclick = () => {
                    if (appState.sortBy === fieldKey) {
                        appState.sortDirection = appState.sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        appState.sortBy = fieldKey;
                        appState.sortDirection = 'asc';
                    }
                    listenForData(collectionName);
                };
                tr.appendChild(th);
            });
            tableHeader.appendChild(tr);

            onSnapshot(q, (snapshot) => {
                if (!tableBody) return;
                
                tableBody.innerHTML = '';
                
                if (snapshot.empty) {
                    const colspan = columnsToShow.length;
                    tableBody.innerHTML = `<tr><td colspan="${colspan}" class="px-6 py-4 text-center text-gray-400">NO ENTRIES FOUND.</td></tr>`;
                    return;
                }
                
                snapshot.forEach((doc) => {
                    const docId = doc.id;
                    const data = doc.data();
                    const newRow = createTableRow(docId, data, collectionName);
                    tableBody.appendChild(newRow);
                });

                // Re-populate rulesCodexMap if rules_codex collection is being listened to
                if (collectionName === 'rules_codex') {
                    populateRulesCodexMap();
                }

            }, error => {
                console.error(`Error listening for data from ${collectionName}:`, error);
                showError(`Failed to load data from ${collectionName}.`);
            });
        }
        
        // --- Form Field Creation Helpers ---

        function createTextField(fieldKey, savedValue, isEditMode) {
            const readonlyAttr = isEditMode ? '' : 'readonly';
            const displayClass = isEditMode ? '' : 'display-only-input';
            return `<input type="text" id="${fieldKey}" name="${fieldKey}" value="${savedValue}" class="global-form-input ${displayClass}" ${readonlyAttr}>`;
        }

        function createNumberField(fieldKey, savedValue, isEditMode) {
            const readonlyAttr = isEditMode ? '' : 'readonly';
            const displayClass = isEditMode ? '' : 'display-only-input';
            return `<input type="number" id="${fieldKey}" name="${fieldKey}" value="${savedValue || 0}" class="global-form-input ${displayClass}" ${readonlyAttr}>`;
        }

        function createTextareaField(fieldKey, savedValue, isEditMode) {
            const readonlyAttr = isEditMode ? '' : 'readonly';
            const displayClass = isEditMode ? '' : 'display-only-input';
            let content = savedValue;
            if (!isEditMode && (fieldKey === 'description' || fieldKey === 'note' || fieldKey === 'mechanic' || fieldKey === 'guide')) { /* Added guide to wiki parsing */
                content = parseWikiLinks(savedValue);
            }
            return `<textarea id="${fieldKey}" name="${fieldKey}" class="global-form-input ${displayClass}" rows="1" ${readonlyAttr}>${content}</textarea>`;
        }

        function createBooleanField(fieldKey, savedValue, isEditMode) {
            const savedBool = savedValue === true || savedValue === 'true';
            if (!isEditMode) {
                return `<div class="global-form-input display-only-input">${savedBool ? 'YES' : 'NO'}</div>`;
            }
            return `<div class="flex gap-4">
                        <label class="flex items-center gap-2">
                            <input type="radio" name="${fieldKey}" value="true" ${savedBool ? 'checked' : ''} class="h-4 w-4 rounded-full border-gray-600 bg-gray-700 text-gray-400 focus:ring-gray-500">
                            <span>YES</span>
                        </label>
                        <label class="flex items-center gap-2">
                            <input type="radio" name="${fieldKey}" value="false" ${!savedBool ? 'checked' : ''} class="h-4 w-4 rounded-full border-gray-600 bg-gray-700 text-gray-400 focus:ring-gray-500">
                            <span>NO</span>
                        </label>
                    </div>`;
        }

        function createRadioField(fieldKey, fieldConfig, savedValue, isEditMode) {
            const options = fieldConfig.options || [];
            const valueToSelect = (savedValue === '' && fieldKey === 'modifier_type') ? 'constant' : savedValue;
            if (!isEditMode) {
                return `<div class="global-form-input display-only-input">${(valueToSelect || '').toUpperCase()}</div>`;
            }
            const radioHtml = options.map(opt => `
                <label class="flex items-center gap-2">
                    <input type="radio" name="${fieldKey}" value="${opt}" ${valueToSelect === opt ? 'checked' : ''} class="h-4 w-4 rounded-full border-gray-600 bg-gray-700 text-gray-400 focus:ring-gray-500">
                    <span>${opt.toUpperCase()}</span>
                </label>
            `).join('');
            return `<div class="flex gap-4">${radioHtml}</div>`;
        }

        async function createSelectField(fieldKey, fieldConfig, savedValue, isEditMode) {
            let options = [];
            if (fieldConfig.source === 'skills_meta') {
                const allSkills = await getCollectionOptions('skills');
                const metaSkills = allSkills.filter(skill => skill.type === 'meta');
                options = [{ name: 'Special Ability'}, ...metaSkills];
            } else if (fieldConfig.source) {
                options = await getCollectionOptions(fieldConfig.source);
            } else if (fieldConfig.options) {
                options = fieldConfig.options.map(opt => ({ name: opt, dc: 0}));
            }
            
            if (!isEditMode) {
                const displayValue = options.find(opt => opt.name === savedValue)?.name || savedValue || '';
                return `<div class="global-form-input display-only-input">${String(displayValue).toUpperCase()}</div>`;
            }

            let optionHtml = options.map(opt => `<option value="${opt.name}" ${savedValue == opt.name ? 'selected' : ''} data-dc="${opt.dc || 0}" data-cp="${opt.cp || 0}">${String(opt.name).toUpperCase()}</option>`).join('');
            return `<select id="${fieldKey}" name="${fieldKey}" class="global-form-input form-select-arrow"><option value="">--CHOOSE--</option>${optionHtml}</select>`;
        }


        async function createMultiselectField(fieldKey, fieldConfig, savedValue, isEditMode) {
            const savedArray = Array.isArray(savedValue) ? savedValue : [];

            if (!isEditMode) {
                const displayValue = savedArray.length > 0 ? savedArray.join(', ').toUpperCase() : 'NONE';
                return `<div class="global-form-input display-only-input">${displayValue}</div>`;
            }

            if (fieldConfig.source === 'all_equipment') {
                const equipmentGroups = await getCollectionOptions(fieldConfig.source);
                let groupedCheckboxHtml = '';
                
                equipmentGroups.forEach(group => {
                    if(group.options.length > 0) {
                        groupedCheckboxHtml += `<h5 class="font-bold text-sm uppercase text-gray-400 mt-2 first:mt-0">${group.label}</h5>`;
                        groupedCheckboxHtml += group.options.map(opt => `
                            <label class="flex items-center space-x-2 p-1 rounded-md pl-2">
                                <input type="checkbox" name="${fieldKey}" value="${opt.name}" ${savedArray.includes(opt.name) ? 'checked' : ''} class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-gray-400 focus:ring-gray-500" data-dc="${opt.dc || 0}" data-cp="${opt.cp || 0}">
                                <span class="uppercase">${opt.name}</span>
                            </label>`).join('');
                    }
                });

                return `<div class="multiselect-container">${groupedCheckboxHtml || `<span class="text-gray-500">No equipment available.</span>`}</div>`;
            }

            let options = await getCollectionOptions(fieldConfig.source);
            if (fieldKey === 'prerequisite' && appState.editingDocId) {
                options = options.filter(opt => opt.id !== appState.editingDocId);
            }

            if (options.length === 0) {
                return `<div class="multiselect-container"><span class="text-gray-500">No options available.</span></div>`;
            } else {
                const checkboxHtml = options.map(opt => `
                    <label class="flex items-center space-x-2 p-1 rounded-md">
                        <input type="checkbox" name="${fieldKey}" value="${opt.name}" data-dc="${opt.dc || 0}" data-cp="${opt.cp || 0}" ${savedArray.includes(opt.name) ? 'checked' : ''} class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-gray-400 focus:ring-gray-500">
                        <span class="uppercase">${opt.name}</span>
                    </label>`).join('');
                return `<div class="multiselect-container">${checkboxHtml}</div>`;
            }
        }

        function createJsonListField(fieldKey, savedValue, isEditMode) {
            if (!isEditMode) {
                let displayValue = savedValue;
                try {
                    const parsed = JSON.parse(savedValue);
                    if (Array.isArray(parsed)) {
                        displayValue = parsed.map(p => `${p.name.toUpperCase()}: ${p.value}`).join(', ');
                    }
                } catch (e) { /* display raw string */ }
                return `<div class="global-form-input display-only-input">${displayValue}</div>`;
            }
            return `<div id="json-list-editor-${fieldKey}" class="p-2 border border-gray-600 rounded-md"></div>
                                        <textarea id="${fieldKey}" name="${fieldKey}" class="hidden">${savedValue}</textarea>`;
        }

        function createReadonlyTextField(fieldKey, savedValue) {
            // This field is always readonly, so no need for isEditMode check here for its own readonly state
            return `<input type="text" id="${fieldKey}" name="${fieldKey}" value="${savedValue || 0}" class="global-form-input cursor-not-allowed display-only-input" readonly>`;
        }

        async function createFormFieldHtml(fieldKey, fieldConfig, savedValue, collectionKey, isEditMode) {
            const labelText = (fieldConfig.label || fieldKey.replace(/_/g, ' ')).toUpperCase();
            let labelHtml = `<label for="${fieldKey}" class="global-form-label">${labelText}</label>`;

            if (fieldConfig.manageable) {
                let onclickAction;
                if (fieldConfig.source === 'all_equipment') {
                    onclickAction = `window.handleNavigateToEquipment()`;
                } else {
                    onclickAction = `window.handleManageClick('${fieldConfig.source}')`;
                }

                labelHtml = `
                    <button type="button" onclick="${onclickAction}" class="flex items-center gap-2 text-sm font-medium mb-1 underline hover:text-white w-full justify-start global-form-label" ${isEditMode ? '' : 'disabled'}>
                        <span>${labelText}</span>
                    </button>`;
            } else if (fieldConfig.aiEnabled) {
                    labelHtml = `
                        <div class="flex justify-between items-center">
                            <label for="${fieldKey}" class="global-form-label">${labelText}</label>
                            <button type="button" id="generate-description-btn" onclick="window.generateDescription('${collectionKey}')" class="flex items-center gap-1.5 text-xs text-gray-400 hover:text-white transition-colors underline" ${isEditMode ? '' : 'style="display:none;"'}>
                                GENERATE
                            </button>
                        </div>`;
            }

            let fieldHtml = '';
            switch (fieldConfig.type) {
                case 'boolean': fieldHtml = createBooleanField(fieldKey, savedValue, isEditMode); break;
                case 'radio': fieldHtml = createRadioField(fieldKey, fieldConfig, savedValue, isEditMode); break; 
                case 'select': fieldHtml = await createSelectField(fieldKey, fieldConfig, savedValue, isEditMode); break;
                case 'multiselect': fieldHtml = await createMultiselectField(fieldKey, fieldConfig, savedValue, isEditMode); break;
                case 'json_list': fieldHtml = createJsonListField(fieldKey, savedValue, isEditMode); break;
                case 'textarea': fieldHtml = createTextareaField(fieldKey, savedValue, isEditMode); break;
                case 'readonlytext': fieldHtml = createReadonlyTextField(fieldKey, savedValue); break; /* Always readonly */
                case 'number': fieldHtml = createNumberField(fieldKey, savedValue, isEditMode); break;
                default: fieldHtml = createTextField(fieldKey, savedValue, isEditMode);
            }
            return `<div>${labelHtml}${fieldHtml}</div>`;
        }
        
        async function openModal(docId = null, data = {}, isEditMode = true) {
            appState.editingDocId = docId;
            const collectionKey = appState.currentSubcollection || appState.currentCollection;
            
            const config = getActiveConfig(collectionKey);
            
            const modalLabel = getSingularLabel(config.label).toUpperCase();
            modalTitle.textContent = `${isEditMode ? 'MANAGE' : 'VIEW'} ${modalLabel}`;
            
            formFieldsContainer.innerHTML = '<div class="text-center">LOADING...</div>';
            entryModal.classList.remove('hidden');
            
            const availableFields = Object.keys(config.fields);
            
            const sortedFieldKeys = availableFields.sort((a, b) => {
                const indexA = masterFieldOrder.indexOf(a);
                const indexB = masterFieldOrder.indexOf(b);
                if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                if (indexA !== -1) return -1;
                if (indexB !== -1) return 1;
                return a.localeCompare(b);
            });
            
            const formHtml = await Promise.all(sortedFieldKeys.map(async (fieldKey) => {
                const fieldConfig = config.fields[fieldKey];
                const savedValue = data[fieldKey] === undefined ? (fieldConfig.type === 'multiselect' ? [] : (fieldConfig.type === 'json_list' ? '[]' : (fieldConfig.type === 'number' ? 0 : ''))) : data[fieldKey];
                return createFormFieldHtml(fieldKey, fieldConfig, savedValue, collectionKey, isEditMode);
            }));

            formFieldsContainer.innerHTML = formHtml.join('');
            
            const modalDataBtn = document.getElementById('modal-data-btn');
            const modalDataDropdown = document.getElementById('modal-data-dropdown');

            // Clear existing buttons first
            modalDataDropdown.innerHTML = '';

            // Conditionally add 'Edit' or 'Save' button
            if (!isEditMode) {
                const editButton = document.createElement('button');
                editButton.type = 'button';
                editButton.id = 'modal-edit-btn';
                editButton.textContent = 'Edit';
                editButton.onclick = () => openModal(docId, data, true); /* Re-open in edit mode */
                modalDataDropdown.appendChild(editButton);
            } else {
                const saveButton = document.createElement('button');
                saveButton.type = 'submit';
                saveButton.setAttribute('form', 'entry-form'); /* Fix: Use setAttribute for 'form' */
                saveButton.id = 'modal-save-btn';
                saveButton.textContent = 'Save';
                modalDataDropdown.appendChild(saveButton);
            }

            modalDataDropdown.innerHTML += `
                <button type="button" id="modal-summary-btn">Summary</button>
                <div class="submenu-container">
                    <span>Local</span>
                    <div class="submenu">
                        <button type="button" id="modal-local-save-btn">Save</button>
                        <button type="button" id="modal-local-load-btn">Load</button>
                    </div>
                </div>
                <button type="button" id="modal-cancel-btn">Cancel</button>
                <button type="button" id="modal-delete-btn" class="text-red-400 hover:bg-red-800">Delete</button>
            `;

            modalDataBtn.onclick = (e) => {
                e.stopPropagation();
                modalDataDropdown.classList.toggle('show');
            }
            
            document.getElementById('modal-summary-btn').onclick = () => showSummaryModal('modal');
            document.getElementById('modal-cancel-btn').onclick = () => closeModal();
            const deleteBtn = document.getElementById('modal-delete-btn');
            deleteBtn.onclick = () => deleteEntry(docId);
            deleteBtn.classList.toggle('hidden', !docId || !isEditMode); /* Hide delete if no docId or not in edit mode */
            document.getElementById('modal-local-save-btn').onclick = () => saveLocal(entryForm, collectionKey);
            document.getElementById('modal-local-load-btn').onclick = () => loadLocal(entryForm);


            window.handleManageClick = handleManageClick;
            window.generateDescription = generateDescription;
            
            const textareas = formFieldsContainer.querySelectorAll('textarea');
            const autosize = (el) => {
                setTimeout(() => {
                    el.style.height = 'auto';
                    el.style.height = (el.scrollHeight) + 'px';
                }, 0);
            };

            textareas.forEach(textarea => {
                textarea.addEventListener('input', () => autosize(textarea));
                autosize(textarea);
            });

            for (const fieldKey of Object.keys(config.fields)) {
                const fieldConfig = config.fields[fieldKey];
                if (fieldConfig.type === 'json_list' && isEditMode) { /* Only setup editor if in edit mode */
                    await setupJsonListEditor(fieldKey, fieldConfig);
                }
            }
            
            if (collectionKey === 'modifier' || collectionKey === 'prerequisite') {
                const aspectSelect = formFieldsContainer.querySelector('#aspect');
                const aspectSubtypeContainer = formFieldsContainer.querySelector('#aspect_subtype')?.parentElement;

                const updateSubtypeOptions = async () => {
                    const selectedAspect = aspectSelect.value;
                    const subtypeSelect = formFieldsContainer.querySelector('#aspect_subtype');
                    if (!subtypeSelect || !aspectSubtypeContainer) return;
                    
                    const currentSubtypeValue = data.aspect_subtype || '';
                    subtypeSelect.innerHTML = '<option value="">--CHOOSE--</option>'; 
                    aspectSubtypeContainer.style.display = 'none';

                    let options = [];
                    
                    const attributeOptions = ['Strength', 'Agility', 'Constitution', 'Intellect', 'Wisdom', 'Charisma', 'Might', 'Reflex', 'Fortitude', 'Logic', 'Will', 'Etiquette'];
                    const skillOptions = async () => {
                        const individualSkills = await getCollectionOptions('skills');
                        return individualSkills.map(s => s.name);
                    };
                    const combatOptions = [
                        'health', 'vitality', 'initiative', 
                        'melee attack', 'ranged attack', 'unarmed attack',
                        'ballistic weapon attack', 'heavy weapon attack', 'energy weapon attack', 'heavy energy weapon attack',
                        'damage', 'melee damage', 'ranged damage', 'critical score', 
                        'dodge', 'parry', 'block', 'charge', 'disarm', 'grapple', 'overrun', 'sunder', 'trip', 'drag', 'aim', 'flanking', 
                        'Head DR', 'Torso DR', 'Right Arm DR', 'Left Arm DR', 'Right Leg DR', 'Left Leg DR'
                    ];
                    const otherOptions = ['karma', 'plot points', 'tech level', 'meta level', 'size', 'durability', 'carry capacity', 'component slot', 'ammunition capacity', 'wealth', 'Walk Speed', 'Swim Speed', 'Climb Speed', 'Fly Speed', 'Perception', 'Meta Perception', 'Social Perception', 'Technology Perception', 'aid'];

                    if (selectedAspect.includes('attribute')) {
                        options = attributeOptions;
                    } else if (selectedAspect.includes('skill')) {
                        options = await skillOptions();
                    } else if (selectedAspect.includes('combat')) {
                        options = combatOptions;
                    } else if (selectedAspect.includes('meta')) {
                        const disciplineOptions = await getCollectionOptions('discipline');
                        const invocationOptions = await getCollectionOptions('invocations');
                        options = [
                            ...disciplineOptions.map(d => d.name),
                            ...invocationOptions.map(i => i.name)
                        ];
                    } else if (selectedAspect.includes('other')) {
                        options = otherOptions;
                    }


                    if (options.length > 0) {
                        options.forEach(opt => {
                            subtypeSelect.innerHTML += `<option value="${opt}" ${currentSubtypeValue === opt ? 'selected' : ''}>${opt.toUpperCase()}</option>`;
                        });
                        aspectSubtypeContainer.style.display = '';
                    }
                    subtypeSelect.value = currentSubtypeValue;
                };

                if(aspectSelect && isEditMode){ /* Only add listener if in edit mode */
                    aspectSelect.addEventListener('change', updateSubtypeOptions);
                    await updateSubtypeOptions();
                }
            }

            // Dynamic fields for 'MANAGE AREA'
            if (collectionKey === 'area') {
                const shapeSelect = formFieldsContainer.querySelector('#shape');
                const dimensionsFieldContainer = formFieldsContainer.querySelector('#dimensions')?.parentElement;

                const updateDimensionsField = () => {
                    if (!shapeSelect || !dimensionsFieldContainer) return;

                    const selectedShape = shapeSelect.value;
                    const savedValue = data.dimensions || '';
                    
                    const label = dimensionsFieldContainer.querySelector('label');
                    dimensionsFieldContainer.innerHTML = '';
                    if (label) dimensionsFieldContainer.appendChild(label);

                    const dimensionOptions = {
                        burst: ['5-foot radius', '15-foot radius', '30-foot radius', '60-foot radius'],
                        cone: ['15-foot length', '30-foot length', '45-foot length'],
                        line: ['30-foot length', '60-foot length', '90-foot length']
                    };

                    if (dimensionOptions[selectedShape]) {
                        const select = document.createElement('select');
                        select.id = 'dimensions';
                        select.name = 'dimensions';
                        select.className = 'global-form-input form-select-arrow';
                        let optionsHtml = '<option value="">--CHOOSE--</option>';
                        optionsHtml += dimensionOptions[selectedShape].map(opt => `<option value="${opt}" ${savedValue === opt ? 'selected' : ''}>${opt.toUpperCase()}</option>`).join('');
                        select.innerHTML = optionsHtml;
                        if (!isEditMode) {
                            select.disabled = true;
                            select.classList.add('display-only-input');
                        }
                        dimensionsFieldContainer.appendChild(select);
                    } else if (selectedShape === 'cubes') {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.id = 'dimensions';
                        input.name = 'dimensions';
                        input.value = '10ft x 10ft x 10ft cube per invocation level';
                        input.className = 'global-form-input cursor-not-allowed bg-gray-600';
                        input.readOnly = true;
                        if (!isEditMode) {
                            input.classList.add('display-only-input');
                        }
                        dimensionsFieldContainer.appendChild(input);
                    } else {
                        const select = document.createElement('select');
                        select.id = 'dimensions';
                        select.name = 'dimensions';
                        select.className = 'global-form-input form-select-arrow';
                        select.disabled = true;
                        select.innerHTML = '<option value="">--SELECT SHAPE FIRST--</option>';
                        if (!isEditMode) {
                            select.classList.add('display-only-input');
                        }
                        dimensionsFieldContainer.appendChild(select);
                    }
                };

                if (shapeSelect && dimensionsFieldContainer) {
                    if (isEditMode) {
                        shapeSelect.addEventListener('change', updateDimensionsField);
                    } else {
                        shapeSelect.disabled = true;
                        shapeSelect.classList.add('display-only-input');
                    }
                    updateDimensionsField(); /* Initial call */
                }
            }
            
            setupDynamicCalculations(formFieldsContainer);
            appState.initialFormState = getFormState(entryForm);

        }

        function setupDynamicCalculations(formContainer) {
            const designDcInput = formContainer.querySelector('#design_dc');
            if (!designDcInput) return;

            const updateTotals = () => {
                let totalDc = 0;
                
                const checkedBoxes = formContainer.querySelectorAll('input[type=checkbox]:checked');
                checkedBoxes.forEach(box => {
                    totalDc += Number(box.dataset.dc) || 0;
                });

                const selects = formContainer.querySelectorAll('select');
                selects.forEach(select => {
                    if (select.selectedOptions.length > 0) {
                        const selectedOption = select.selectedOptions[0];
                        if (selectedOption && selectedOption.value) { 
                            totalDc += Number(selectedOption.dataset.dc) || 0;
                        }
                    }
                });
                
                designDcInput.value = totalDc;
            };

            const allSelectableInputs = formContainer.querySelectorAll('select, input[type=checkbox]');
            allSelectableInputs.forEach(input => {
                // Only add event listeners if in edit mode
                if (!input.readOnly && !input.disabled) { 
                    input.addEventListener('change', updateTotals);
                }
            });

            updateTotals();
        }


        async function setupJsonListEditor(fieldKey, fieldConfig) {
            const editorContainer = document.getElementById(`json-list-editor-${fieldKey}`);
            const textarea = document.getElementById(fieldKey);
            let items = [];
            try {
                const parsed = JSON.parse(textarea.value);
                if (Array.isArray(parsed)) {
                    items = parsed;
                }
            } catch (e) {
                console.error("Could not parse prerequisite JSON:", textarea.value);
                items = [];
            }

            const redrawList = () => {
                editorContainer.innerHTML = '';
                const listContainer = document.createElement('div');
                listContainer.className = 'space-y-2 mb-2';
                items.forEach((item, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'prereq-item';
                    itemEl.innerHTML = `<span>${item.name.toUpperCase()}: ${item.value}</span>`;
                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.className = 'ml-4 font-bold text-red-500 hover:text-red-300';
                    removeBtn.onclick = () => {
                        items.splice(index, 1);
                        textarea.value = JSON.stringify(items);
                        redrawList();
                    };
                    itemEl.appendChild(removeBtn);
                    listContainer.appendChild(itemEl);
                });
                editorContainer.appendChild(listContainer);
                
                const addBtn = document.createElement('button');
                addBtn.type = 'button';
                addBtn.textContent = 'ADD REQUIREMENT';
                addBtn.className = 'btn btn-secondary w-full !py-1 !text-xs';
                addBtn.onclick = () => showAddForm();
                editorContainer.appendChild(addBtn);
            };
            
            const showAddForm = async () => {
                editorContainer.innerHTML = ''; /* Clear to show the form */
                const formContainer = document.createElement('div');
                formContainer.className = 'p-2 space-y-2 rounded-md';
                formContainer.style.backgroundColor = 'var(--bg-main)';
                
                let selectOptions = [];
                if (fieldConfig.source) {
                    let sourceItems = await getCollectionOptions(fieldConfig.source);
                    if (fieldConfig.source === 'feature' && appState.editingDocId) {
                            sourceItems = sourceItems.filter(item => item.id !== appState.editingDocId);
                    }
                    selectOptions = sourceItems.map(item => `<option value="${item.name}">${item.name.toUpperCase()}</option>`);
                } else if (fieldConfig.options) {
                    selectOptions = fieldConfig.options.map(opt => `<option value="${opt}">${opt.toUpperCase()}</option>`);
                }

                const valueInputHtml = (fieldConfig.source === 'feature') ? '' : `<input type="number" id="prereq-value-input" class="global-form-input" placeholder="VALUE" value="1">`;


                formContainer.innerHTML = `
                    <select class="global-form-input form-select-arrow" id="prereq-name-input">${selectOptions.join('')}</select>
                    ${valueInputHtml}
                    <div class="flex justify-end gap-2">
                        <button type="button" id="prereq-cancel-btn" class="btn btn-secondary !text-xs !py-1 !px-2">CANCEL</button>
                        <button type="button" id="prereq-add-btn" class="btn btn-primary !text-xs !py-1 !px-2">ADD</button>
                    </div>
                `;
                
                editorContainer.appendChild(formContainer);

                document.getElementById('prereq-cancel-btn').onclick = () => redrawList();
                document.getElementById('prereq-add-btn').onclick = () => {
                    const nameInput = document.getElementById('prereq-name-input');
                    const valueInput = document.getElementById('prereq-value-input');
                    const value = (fieldConfig.source === 'feature') ? 1 : (valueInput ? Number(valueInput.value) : 1);

                    if (nameInput.value) {
                        items.push({ name: nameInput.value, value: value });
                        textarea.value = JSON.stringify(items);
                        redrawList();
                    }
                };
            };

            redrawList();
        }

        function closeModal(force = false) {
            const isModalOpen = !entryModal.classList.contains('hidden');
            if (!force && isModalOpen && isFormDirty()) {
                appState.pendingNavigation = null; /* Clear pending nav if any */
                unsavedChangesModal.classList.remove('hidden');
                return;
            }
            appState.initialFormState = null;
            appState.editingDocId = null;
            if (!force) {
                appState.navigationContext = null;
            }
            if(entryForm) entryForm.reset();
            const modalDataDropdown = document.getElementById('modal-data-dropdown');
            if(modalDataDropdown) modalDataDropdown.innerHTML = '';
            if(entryModal) entryModal.classList.add('hidden');
        }

        async function handleFormSubmit(e) {
            e.preventDefault();
            if (!appState.userId) return false;

            const collectionKey = appState.currentSubcollection || appState.currentCollection;
            
            const config = getActiveConfig(collectionKey);

            const data = getFormDataObject(entryForm);
            
            // --- Validation ---
            for (const fieldKey in config.fields) {
                const fieldConfig = config.fields[fieldKey];
                const fieldElement = document.getElementById(fieldKey);
                
                if (fieldConfig.required) {
                    if (!data[fieldKey] || (typeof data[fieldKey] === 'string' && data[fieldKey].trim() === "")) {
                        showError(`${fieldConfig.label || fieldKey} is required.`);
                        if (fieldElement) {
                            fieldElement.classList.add('!border-red-500');
                            fieldElement.focus();
                            fieldElement.addEventListener('input', () => {
                                fieldElement.classList.remove('!border-red-500');
                            }, { once: true });
                        }
                        return false;
                    }
                }
            }
            
            if(data.is_specialization) {
                data.is_specialization = data.is_specialization === 'true';
                if (data.is_specialization && !data.base_skill) {
                    showError("Base Skill is required for a specialization.");
                    const baseSkillField = document.getElementById('base_skill');
                    if (baseSkillField) {
                        baseSkillField.classList.add('!border-red-500');
                        baseSkillField.focus();
                        baseSkillField.addEventListener('change', () => {
                            baseSkillField.classList.remove('!border-red-500');
                        }, { once: true });
                    }
                    return false;
                }
            }
            if(data.is_specialization === false) {
                data.base_skill = '';
            }
            if(data.restricted) {
                data.restricted = data.restricted === 'true'
            }

            const collectionPath = `artifacts/${appId}/public/data/${collectionKey}`;
            try {
                if (appState.editingDocId) {
                    await updateDoc(doc(db, collectionPath, appState.editingDocId), data);
                } else {
                    await addDoc(collection(db, collectionPath), data);
                }
                
                const shouldStayOpen = !!appState.pendingNavigation;
                if(!shouldStayOpen) {
                    closeModal(true);
                }
                return true;
            } catch (error) {
                console.error("Error saving data:", error);
                showError("Error saving data. Check console for details.");
                return false;
            }
        }
        
        function deleteEntry(docId) {
            if (!appState.userId) return;
            showConfirmModal(`ARE YOU SURE YOU WANT TO DELETE THIS ENTRY? THIS ACTION CANNOT BE UNDONE.`, async () => {
                closeModal();
                const collectionKey = appState.currentSubcollection || appState.currentCollection;
                const collectionPath = `artifacts/${appId}/public/data/${collectionKey}`;
                try {
                    await deleteDoc(doc(db, collectionPath, docId));
                    // If the deleted entry was the currently displayed wiki entry, clear the display
                    if (collectionKey === 'rules_codex' && appState.currentWikiEntryId === docId) {
                        document.getElementById('wiki-entry-title').textContent = 'Select an Entry';
                        document.getElementById('wiki-entry-body').innerHTML = '<p class="text-gray-400">Please select an entry from the left sidebar or create a new one.</p>';
                        document.getElementById('wiki-edit-btn').style.display = 'none';
                        document.getElementById('wiki-delete-btn').style.display = 'none';
                        appState.currentWikiEntryId = null;
                    }
                } catch (error) {
                    console.error("Error deleting document:", error);
                    showError("Error deleting entry. Check console for details.");
                }
            });
        }

        function showConfirmModal(message, onConfirm) {
            const confirmModalEl = document.getElementById('confirm-modal');
            const confirmMessageEl = document.getElementById('confirm-message');
            const confirmOkBtnEl = document.getElementById('confirm-ok-btn');
            const confirmCancelBtnEl = document.getElementById('confirm-cancel-btn');

            confirmMessageEl.textContent = message;
            appState.confirmCallback = onConfirm;

            confirmOkBtnEl.onclick = () => {
                if (appState.confirmCallback) appState.confirmCallback();
                confirmModalEl.classList.add('hidden');
            };
            confirmCancelBtnEl.onclick = () => {
                confirmModalEl.classList.add('hidden');
            };

            confirmModalEl.classList.remove('hidden');
        }

        function hideConfirmModal() { appState.confirmCallback = null; confirmModal.classList.add('hidden'); }
        function hideUnsavedChangesModal() {
            appState.pendingNavigation = null;
            unsavedChangesModal.classList.add('hidden');
        }
        function showError(message) { errorMessage.textContent = message.toUpperCase(); errorModal.classList.remove('hidden'); }
        function hideErrorModal() { errorModal.classList.add('hidden'); }
        
        async function generateDescription(categoryKey) {
            const btn = document.getElementById('generate-description-btn');
            if(!btn) return;

            const originalContent = btn.innerHTML;
            btn.innerHTML = '<div class="loader"></div>';
            btn.disabled = true;

            const data = getFormDataObject();
            let prompt = `Generate a detailed and creative encyclopedia entry for a sci-fi RPG. The category is "${categoryKey}".\n`;
            prompt += `The entry's name is "${data.name}".\n`;

            if(data.trait && data.trait.length > 0) prompt += `It has the following traits: ${data.trait.join(', ')}.\n`;
            if(data.type) prompt += `It belongs to the following type: ${data.type}.\n`;
            if(data.goals) prompt += `Its primary goals are: ${data.goals}.\n`;

            prompt += `\nWrite an engaging description suitable for a game master's guide. Be evocative and inspiring.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "" // No API key needed for gemini-2.0-flash
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    const descriptionTextarea = document.getElementById('description');
                    if(descriptionTextarea) {
                        descriptionTextarea.value = text;
                        // Trigger autosize
                        const autosize = (el) => {
                            setTimeout(() => {
                                el.style.height = 'auto';
                                el.style.height = (el.scrollHeight) + 'px';
                            }, 0);
                        };
                        autosize(descriptionTextarea);
                    }
                } else {
                    showError("Could not generate description. The model returned an empty response.");
                }
            } catch (error) {
                console.error("Error generating description:", error);
                showError("Failed to generate description. Check the console for details.");
            } finally {
                btn.innerHTML = originalContent;
                btn.disabled = false;
            }
        }
        window.generateDescription = generateDescription;
        
        // Function to parse text for wiki-style links and replace them with clickable anchors
        function parseWikiLinks(text) {
            if (!text) return '';
            return text.replace(/\[\[(.*?)\]\]/g, (match, p1) => {
                const entryName = p1.trim();
                const docId = rulesCodexMap.get(entryName);
                if (docId) {
                    return `<a href="#" class="wiki-link" data-linked-id="${docId}" data-linked-name="${entryName}">${entryName}</a>`;
                }
                return entryName; /* If no matching entry, just display the text without a link */
            });
        }

        // Event listener for clicks on wiki-links within the modal
        entryModal.addEventListener('click', async (event) => {
            if (event.target.classList.contains('wiki-link')) {
                event.preventDefault();
                const linkedDocId = event.target.dataset.linkedId;
                const linkedDocName = event.target.dataset.linkedName;

                if (linkedDocId) {
                    const collectionPath = `artifacts/${appId}/public/data/rules_codex`;
                    try {
                        const docSnap = await getDoc(doc(db, collectionPath, linkedDocId));
                        if (docSnap.exists()) {
                            // Close current modal first if it's not the main one
                            if (appState.editingDocId !== linkedDocId) {
                                closeModal(true); /* Force close current modal */
                            }
                            // Open the linked document in read-only mode
                            openModal(linkedDocId, docSnap.data(), false); 
                        } else {
                            showError(`Linked entry "${linkedDocName}" not found.`);
                        }
                    } catch (error) {
                        console.error("Error fetching linked document:", error);
                        showError(`Could not load linked entry "${linkedDocName}".`);
                    }
                }
            }
        });


        // --- Event Listeners ---
        confirmOkBtn.onclick = () => { if (appState.confirmCallback) appState.confirmCallback(); hideConfirmModal(); };
        confirmCancelBtn.onclick = hideConfirmModal;
        unsavedCancelBtn.onclick = hideUnsavedChangesModal;
        unsavedDismissBtn.onclick = () => {
            closeModal(true);
            if(appState.pendingNavigation) {
                appState.pendingNavigation();
                appState.pendingNavigation = null;
                appState.navigationContext = null;
            }
            hideUnsavedChangesModal();
        }
        unsavedSaveBtn.onclick = async () => {
            let success = false;
            if (appState.currentCollection === 'persona_folio') {
                 await saveFolio(); // saveFolio is async but we don't need to check its return
                 success = true; // Assume success for navigation purposes
            } else {
                 success = await handleFormSubmit(new Event('submit',{bubbles:true}));
            }

            if(success && appState.pendingNavigation) {
                appState.pendingNavigation();
                appState.pendingNavigation = null;
                appState.navigationContext = null;
            }
            hideUnsavedChangesModal();
        }

        errorOkBtn.onclick = hideErrorModal;
        helpCloseBtn.onclick = () => { helpModal.classList.add('hidden'); };
        summaryCloseBtn.onclick = () => { summaryModal.classList.add('hidden'); };
        
        window.onclick = (event) => {
            if (event.target == entryModal || event.target == confirmModal || event.target == errorModal || event.target == unsavedChangesModal || event.target == helpModal || event.target == customModal || event.target == summaryModal) {
                if (event.target === entryModal) {
                    appState.navigationContext = null;
                }
                if (event.target == customModal) {
                    customModal.classList.add('hidden');
                }
                if (event.target == summaryModal) {
                    summaryModal.classList.add('hidden');
                }
                requestNavigation(closeModal);
                hideConfirmModal();
                hideErrorModal();
                hideUnsavedChangesModal();
                if (event.target == helpModal) {
                    helpModal.classList.add('hidden');
                }
            }
            const menuButton = document.getElementById('category-menu-button');
            const dropdownMenu = document.getElementById('category-dropdown-menu');
            if (menuButton && dropdownMenu && !menuButton.contains(event.target) && !dropdownMenu.contains(event.target)) {
                dropdownMenu.classList.add('hidden');
            }
            
            const folioMenuButton = document.querySelector('.persona-folio-container .file-menu-button');
            const folioDropdownMenu = document.querySelector('.persona-folio-container .file-menu-dropdown');
            if (folioMenuButton && folioDropdownMenu && !folioMenuButton.contains(event.target) && !folioDropdownMenu.contains(event.target)) {
                folioDropdownMenu.classList.remove('show');
            }
            
            const modalDataBtn = document.getElementById('modal-data-btn');
            const modalDataDropdown = document.getElementById('modal-data-dropdown');
            if (modalDataBtn && modalDataDropdown && !modalDataBtn.contains(event.target) && !modalDataDropdown.contains(event.target)) {
                modalDataDropdown.classList.remove('show');
            }
        };

        const helpMarkdown = ``; /* Cleared content */
        
        function convertMarkdownToHtml(markdown) {
            const lines = markdown.trim().split('\n');
            let html = '';
            let listStack = []; /* To track open <ul> or <ol> */

            for (const line of lines) {
                if (line.trim() === '') continue;

                const indentMatch = line.match(/^(\s*)/);
                const indent = indentMatch ? indentMatch[1].length : 0;
                let trimmedLine = line.trim();

                /* Close lists when de-denting */
                while (listStack.length > 0 && indent < listStack[listStack.length - 1].indent) {
                    html += `</${listStack.pop().type}>`;
                    if (listStack.length > 0 && html.endsWith('</li>')) {
                        /* Don't close the li if it's the last one in the parent */
                    } else {
                        html += '</li>';
                    }
                }

                if (trimmedLine.startsWith('### ')) {
                    html += `<h3 class="text-2xl font-bold mt-6 mb-2 text-gray-100">${trimmedLine.substring(4)}</h3>`;
                } else if (trimmedLine.startsWith('#### **')) {
                    html += `<h4 class="text-lg font-semibold mt-4 mb-1 text-gray-200">${trimmedLine.substring(6, trimmedLine.length - 2)}</h4>`;
                } else if (trimmedLine.startsWith('* ')) {
                    if (listStack.length === 0 || indent > listStack[listStack.length - 1].indent || listStack[listStack.length-1].type !== 'ul') {
                        if (listStack.length > 0 && indent <= listStack[listStack.length-1].indent) {
                            html += `</${listStack.pop().type}></li>`;
                        }
                        html += `<ul class="list-disc list-inside ml-4 space-y-1">`;
                        listStack.push({ type: 'ul', indent });
                    }
                    let content = trimmedLine.substring(2).replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    html += `<li>${content}`; /* Don't self-close */
                } else if (trimmedLine.match(/^\d+\. /)) {
                    if (listStack.length === 0 || indent > listStack[listStack.length - 1].indent || listStack[listStack.length-1].type !== 'ol') {
                        if (listStack.length > 0 && indent <= listStack[listStack.length-1].indent) {
                            html += `</${listStack.pop().type}></li>`;
                        }
                        /* This assumes numbered lists are always nested inside bullet points. */
                        html = html.slice(0, -5); /* remove last </li> */
                        html += `<ol class="list-decimal list-inside space-y-1 mt-1 ml-8">`;
                        listStack.push({ type: 'ol', indent });
                    }
                    html += `<li>${trimmedLine.replace(/^\d+\. /, '')}</li>`;
                } else {
                    /* Close any open lists before a paragraph */
                    while (listStack.length > 0) {
                        html += `</li></${listStack.pop().type}>`;
                    }
                    html += `<p class="mt-2">${trimmedLine}</p>`;
                }
            }
            
            /* Close any remaining open lists */
            while (listStack.length > 0) {
                html += `</li></${listStack.pop().type}>`;
            }

            /* Final replacements for inline elements */
            return html.replace(/`([^`]+)`/g, '<code class="bg-gray-700 text-gray-300 rounded px-1 py-0.5">$1</code>');
        }

        helpContent.innerHTML = convertMarkdownToHtml(helpMarkdown);

        window.folioManager = {
            openSubManager: (collectionKey) => {
                const parentKey = Object.keys(categoryConfig).find(key => 
                    (categoryConfig[key].subcategories && categoryConfig[key].subcategories[collectionKey])
                ) || collectionKey;
                
                requestNavigation(() => {
                    navigateTo(() => renderManagementView(collectionKey, parentKey));
                });
            }
        };

        window.onload = function() {
            /* Entry point */
            if (appState.userId) {
                navigateTo(() => renderCategoryView('other'));
            }
        };
    </script>
</body>
</html>
